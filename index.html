
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>左手代码 右手年华</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一个尘世迷途小码农的程序与人生">
<meta property="og:type" content="website">
<meta property="og:title" content="左手代码 右手年华">
<meta property="og:url" content="http://www.harrycode.com/index.html">
<meta property="og:site_name" content="左手代码 右手年华">
<meta property="og:description" content="一个尘世迷途小码农的程序与人生">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="左手代码 右手年华">
<meta name="twitter:description" content="一个尘世迷途小码农的程序与人生">
  
    <link rel="alternative" href="/atom.xml" title="左手代码 右手年华" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">左手代码 右手年华</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个尘世迷途小码农的程序与人生</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="www.harrycode.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-nginx-manual-note-CORE-FUNC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/05/nginx-manual-note-CORE-FUNC/" class="article-date">
  <time datetime="2015-07-05T06:30:00.000Z" itemprop="datePublished">2015-07-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/05/nginx-manual-note-CORE-FUNC/">Nginx手册阅读笔记 —— 核心指令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="URL:_[http://nginx-org/en/docs/ngx_core_module-html]">URL: [<a href="http://nginx.org/en/docs/ngx_core_module.html" target="_blank" rel="external">http://nginx.org/en/docs/ngx_core_module.html</a>]</h2><p><code>accept_mutex on | off</code><br>如果开启，worker进程将轮流接收新请求。否则，有新请求到来时，所有的worker进程将集体被唤醒，而此时如果请求流量较低，一些worker进程只会浪费系统资源。 参考： [<a href="http://huoding.com/2013/08/24/281" target="_blank" rel="external">http://huoding.com/2013/08/24/281</a>]</p>
<p><code>accept_mutex_delay time</code><br>启动<code>accept_mutex</code>后，每个worker进程重新接受新请求的最大时间间隔。默认值 500ms</p>
<p><code>debug_connection</code><br>对指定的客户端请求启动debug模式。其它请求使用<code>error_log</code>指令设置的日志级别。可以指定 IP/主机名/unix套接字。 这个指令的生效需要在编译时指定 —with-debug<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    debug_connection <span class="number">127.0</span>.0.1;</span><br><span class="line">    debug_connection localhost;</span><br><span class="line">    debug_connection <span class="number">192.0</span>.2.0/<span class="number">24</span>;</span><br><span class="line">    <span class="string">debug_connection :</span>:<span class="number">1</span>;</span><br><span class="line">    debug_connection <span class="number">2001</span>:<span class="number">0</span><span class="string">db8:</span>:/<span class="number">32</span>;</span><br><span class="line">    debug_connection <span class="string">unix:</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>debug_points abort | stop</code><br>当发生严重的内部错误，开启此选项会创建一个core-file（abort）或停止进程已便于后续分析。</p>
<p><code>lock_file file</code><br>nginx使用锁机制来实现<code>accept_mutex</code>，并将访问串行化到共享内存。大部分系统的锁操作是原子的，这条指令会被忽略。另外一部分系统使用文件锁，这条指令指定了锁文件的前缀。默认值为 <code>lock_file logs/nginx.lock</code></p>
<p><code>multi_accept on | off</code><br>关闭时一个worker进程每次接受一个请求。开启时，每接到一个请求，就尽可能的取走全部的请求。</p>
<p><code>pcre_jit on | off</code><br>开启/关闭正则表达式的”实时编译”。PCRE JIT可以显著提升处理正则表达式的速度。当使用PCRE源码库编译nginx时(—with-pcre=)， 应该使用nginx的—with-pcre-jit编译选项开启JIT支持。</p>
<p><code>thread_pool name threads=number [max_queue=number]</code><br>定义线程池的名字，线程数量以及任务队列的最大长度。一个请求事件，如果线程池中的所有线程都处于忙碌状态，请求会被塞入任务队列。 <code>max_queue</code> 定义了任务队列的最大长度，默认值为65535。当任务队列溢出，任务将会以一个error进入完成状态。</p>
<p><code>timer_resolution interval</code><br>降低定时器的精度，进而减少gettimeofday()的系统调用数。默认情况下，每当有内核事件，都会调用gettimeofday()。使用此指令后，nginx只在固定时间间隔后才会调用。</p>
<p><code>worker_connections number</code><br>设置每个worker 进程可以处理的最大并发连接数。需要注意的是，这个数字包含所有连接(如后端连接以及其它的)，而不仅仅是客户端连接。另一个需要注意的是，实际的并发连接数不能超过当前打开文件的最大限制。这个限制可以使用<code>worker_rlimit_nofile</code>来指定。</p>
<p><code>worker_cpu_affinity cpumask ...</code><br>绑定worker进程到指定cpu。每个cpu用一个掩码来标识，需要为每个worker进程单独指定。worker进程默认不会绑定到cpu<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">比如</span><br><span class="line"></span><br><span class="line">worker_processes    <span class="number">4</span>;</span><br><span class="line">worker_cpu_affinity <span class="number">0001</span> <span class="number">0010</span> <span class="number">0100</span> <span class="number">1000</span>;</span><br><span class="line">将每个工作进程分别绑定至不同的CPU，而</span><br><span class="line"></span><br><span class="line">worker_processes    <span class="number">2</span>;</span><br><span class="line">worker_cpu_affinity <span class="number">0101</span> <span class="number">1010</span>;</span><br><span class="line">将第一个工作进程绑定至CPU0<span class="regexp">/CPU2，将第二个工作进程绑定至CPU1/</span>CPU3。</span><br></pre></td></tr></table></figure></p>
<p><code>worker_processes number | auto</code><br>定义worker进程数。建议设置为当前cpu的核数，<code>auto</code> 会自动检测。</p>
<p><code>worker_rlimit_core size</code><br>定义worker进程core文件的尺寸。</p>
<p><code>worker_rlimit_nofile number</code><br>定义worker进程打开文件的最大数</p>
<p><code>working_directory directory</code><br>定义worker进程的工作目录。主要用来写core-file。worker进程需要有写权限。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.harrycode.com/2015/07/05/nginx-manual-note-CORE-FUNC/" data-id="cibq3ipoe000jgh6aa3j6372y" class="article-share-link">分享到</a>
      

      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-2014-12-03-to-hadoop-working-mechanism" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/03/2014-12-03-to-hadoop-working-mechanism/" class="article-date">
  <time datetime="2014-12-03T09:53:00.000Z" itemprop="datePublished">2014-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/03/2014-12-03-to-hadoop-working-mechanism/">[转]  Hadoop工作机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[来源: <a href="http://blog.csdn.net/suifeng3051/article/details/22416305" target="_blank" rel="external">http://blog.csdn.net/suifeng3051/article/details/22416305</a>]</p>
<p>可以只用一行代码来运行MapReduce作业：JobClient.runJon(conf)，Job作业运行时参与的四个实体：<br>1.JobClient 写代码，配置作业，提交作业。<br>2.JobTracker:初始化作业，分配作业，协调作业运行。这是一个java程序，主类是JobTracker。<br>3.TaskTracker：运行作业划分后的任务，即分配数据分配上执行Map或Reduce任务。<br>4.HDFS：保存作业数据、配置信息等，保存作业结果。</p>
<h2 id="Map/Reduce_作业总体执行流程">Map/Reduce 作业总体执行流程</h2><p><code>代码编写 ----&gt; 作业配置  ----&gt;  作业提交 ----&gt; Map任务分配和执行 ----&gt; 处理中间结果 ----&gt;  Reduce任务分配与执行 ----&gt;  输出结果</code></p>
<h2 id="而对于每个作业的执行，又包含">而对于每个作业的执行，又包含</h2><p><code>输入准备 ----&gt; 任务执行 ----&gt; 输出结果</code></p>
<h2 id="作业提交JobClient">作业提交JobClient</h2><p>JobClient的runJob方法产生一个Jobclient实例并调用其submitJob方法，然后runJob开始循环吗，并在循环中调用getTaskCompetionEvents方法，获得TaskCompletionEvent实例，每秒轮询作业进度（后面有介绍进度和状态更新），把进度写到控制台，作业完成后显示作业计数器，若失败，则把错误记录到控制台。<br>    submitJob方法作业提交的过程：</p>
<pre><code><span class="bullet">1. </span>向JobTracker请求一个新的JobId。
<span class="bullet">2. </span>检查作业相关路径，如果路径不正确就会返回错误。
<span class="bullet">3. </span>计算作业输入分片及其划分信息。
<span class="bullet">4. </span>将作业运行需要的资源（jar文件、配置文件等）复制到Shared HDFS，并复制多个副本（参数控制，默认值为10）供tasktracker访问，也会将计算的分片复制到HDFS。
<span class="bullet">5. </span>调用JobTracker对象的submitJob()方法来真正提交作业，告诉JobTracker作业准备执行。
</code></pre><h2 id="作业的初始化JobTracker">作业的初始化JobTracker</h2><p>JobTracker收到submitJob方法调用后，会把调用放入到一个内部队列，由作业调度器（Job scheduler）进行调度并对其初始化。Job初始化即创建一个作业对象。<br>当作业被调度后，JobTracker会创建一个代表这个作业的JobInProgress对象，并将任务和记录信息封装在这个对象中，以便跟踪任务状态和进程。<br>  初始化过程就是JobInProgress对象的initTasks方法进行初始化的。<br>  初始化步骤：</p>
<pre><code>    <span class="number">1</span>. 从<span class="type">HDFS</span>中读取作业对应的job.<span class="built_in">split</span>信息，为后面的初始化做好准备。
<span class="number">2</span>. 创建并初始化<span class="built_in">map</span>和<span class="built_in">reduce</span>任务。根据数据分片信息中的个数确定<span class="built_in">map</span> task的个数，然后为每个<span class="built_in">map</span> task生成一个<span class="type">TaskInProgress</span>对象来处理数据分片，先将其放入nonRunningMapCache,以便<span class="type">JobTracker</span>分配任务的时候使用。接下来根据<span class="type">JobConf</span>中的mapred.<span class="built_in">reduce</span>.tasks属性利用setNumReduceTasks()方法设置<span class="built_in">reduce</span> task的数量，然后同<span class="built_in">map</span> task创建方式。
<span class="number">3</span>. 最后就是创建两个初始化task，进行<span class="built_in">map</span>和<span class="built_in">reduce</span>的初始化。
</code></pre><h2 id="任务的分配JobTracker">任务的分配JobTracker</h2><p>消息传递HeartBeat： tasktracker运行一个简单循环定期发送心跳（heartbeat）给JobTracker。由心跳告知JobTracker自己是否存活，同时作为消息通道传递其它信息（请求新task）。作为心跳的一部分，tasktracker会指明自己是否已准备好运行新的任务，如果是，jobtracker会分配它一个任务。<br>分配任务所属于的作业：在Jobtracker分配任务前需先确定任务所在的作业。后面会介绍到各种作业调度算法，默认是一个FIFO的作业调度。<br>分配Map和Reduce任务：tasktracker有固定数量的任务槽,一个tasktracker可以同时运行多个Map和Reduce任务，但其准确的数量由tasktracker的核的数量和内存大小决定。默认调度器会先填满Map任务槽，再填Reduce任务槽。jobtracker会选择距离离分片文件最近的tasktracker，最理想情况下，任务是数据本地化（data-local）的,当然也可以是机架本地化（rack-local），如果不是本地化的，那么他们就需要从其他机架上检索数据。Reduce任务分配很简单，jobtracker会简单的从待运行的reduce任务列表中选取下一个来执行，不用考虑数据本地化。</p>
<h2 id="任务的执行TaskTracker">任务的执行TaskTracker</h2><p>TaskTracker收到新任务后，就要在本地运行任务了，运行任务的第一步就是通过localizedJob将任务本地化所需要的注入配置、数据、程序等信息进行本地化。<br>  1.本地化数据：从共享文件系统将job.split 、job.jar (在分布式缓存中)复制本地，将job配置信息写入job.xml。<br>  2.新建本地工作目录：tasktracker会加压job.jar文件到本工作目录。<br>  3.调用launchTaskForJob方法发布任务（其中会新建TaskRunner实例运行任务），如果是Map任务就启用MapTaskRunner，对于Reduce就是ReduceTaskRunner。</p>
<p>在这之后，TaskRunner会启用一个新的JVM来运行每个Map/Reduce任务，防止程序原因而导致tasktracker崩溃，但不同任务间重用JVM还是可以的，后续会讲到任务JVM重用。<br>    对于单个Map，任务执行的简单流程是：<br>  1.分配任务执行参数<br>    2.在Child临时文件中添加map任务信息（Child是运行Map和Reduce任务的主进程）<br>  3.配置log文件夹，配置map任务的通信和输出参数<br>  4.读取input split，生成RecordReader读取数据<br>  5.为Map生成MapRunnable,依次从RecordReader中接收数据，并调用Map函数进行处理。<br>  6.最后将map函数的输出调用collect收集到MapOutputBuffer（参数控制其大小）中。</p>
<h2 id="Streaming和Pipes">Streaming和Pipes</h2><p>Streaming和Pipes都运行特殊的Map和Reduce任务，目的是运行用户提供的可执行程序并与之通信。<br>Streaming:使用标准输入输出Streaming与进程进行通信。<br>Pipes:用来监听套接字，会发送一个端口号给C++程序，两者便可建立链接。</p>
<h2 id="进度和状态更新">进度和状态更新</h2><p>一个作业和它的任务都有状态（status），其中包括：运行成功失败状态、Map/Reduce进度、作业计数器值、状态消息。<br>状态消息与客户端的通信：<br>    1.对于Map任务Progress的追踪：progress是已经处理完的输入所占的比例。<br>  2.对于Reduce：稍复杂，reduce任务分三个阶段（每个阶段占1/3），复制、排序和Reduce处理，若reduce已执行一半的输入的话，那么任务进度便是1/3+1/3+1/6=5/6。<br>  3.任务计数器：任务有一组计数器，负责对任务运行各个事件进行计数。<br>  4.任务进度报告：如果任务报告了进度，便会设置一个标记以表明状态将被发送到tasktracker。有一个独立线程每隔三秒检查一次此标记，如果已设置，则告知tasktracker当前状态。<br>  5.tasktracker进度报告：tasktracker会每隔5秒（这个心跳是由集群大小决定，集群越大时间会越长）发送heartbeat到jobtracker，并且tasktracker运行的所有状态都会在调用中被发送到jobtracker。<br>  6.jobtracker合并各任务报告：产生一个表明所有运行作业机器所含任务状态的全局视图。<br>  前面提到的JobClient就是通过每秒查询JobTracker来接收最新状态，而且客户端JobClient的getJob方法可以得到一个RunningJob的实例，其包含了作业的所以状态信息。</p>
<h2 id="作业的完成">作业的完成</h2><p>当jobtracker收到作业最后一个任务已完成的通知后，便把作业状态设置成成功。JobClient查询状态时，便知道任务已成功完成，于是JobClient打印一条消息告知用户，然后从runJob方法返回。<br>如果jobtracker有相应设置，也会发送一个Http作业通知给客户端，希望收到回调指令的客户端可以通过job.end.notification.url属性来进行设置。<br>jobtracker情况作业的工作状态，指示tasktracker也清空作业的工作状态，如删除中间输出。</p>
<h2 id="失败">失败</h2><p>实际情况下，用户的代码存在软件错误进程会崩溃，机器也会产生故障，但Hadoop能很好的应对这些故障并完成作业。<br>1.任务失败<br>    子任务异常：如Map/Reduce任务中的用户代码抛出异常，子任务JVM进程会在退出前向父进程tasktracker发送错误报告，错误被记录用户日志。tasktracker会将此次task attempt标记为tailed，并释放这个任务槽运行另外一个任务。<br>    子进程JVM突然退出：可能由于JVM bug导致用户代码造成的某些特殊原因导致JVM退出，这种情况下，tasktracker会注意到进程已经退出，并将此次尝试标记为failed。<br>    任务挂起：一旦tasktracker注意一段时间没有收到进度更新，便会将任务标记为failed，JVM子进程将被自动杀死。任务失败间隔时间通常为10分钟，可以以作业或者集群为基础设置过期时间，参数为mapred.task.timeout。注意：如果参数值设置为0，则挂起的任务永远不会释放掉它的任务槽，随着时间的推移会降低整个集群的效率。<br>    任务失败尝试次数：jobtracker得知一个tasktracker失败后，它会重新调度该任务执行，当然，jobtracker会尝试避免重新调度失败过的tasktracker任务。如果一个任务尝试次数超过4次，它将不再被重试。这个值是可以设置的，对于Map任务，参数是mapred.map.max.attempts,对于reduce任务，则由mapred.reduce.max.attempts属性控制。如果次数超过限制，整个作业都会失败。当然，有时我们不希望少数几个任务失败就终止运行的整个作业，因为即使有些任务失败，作业的一些结果可能还是有用的，这种情况下，可以为作业设置在不触发作业失败情况下的允许任务失败的最大百分比，Map任务和Reduce任务可以独立控制，参数为mapred.max.map.failures.percent 和mapred.max.reduce.failures.percent。<br>    任务尝试中止（kill）：任务终止和任务失败不同，task attempt可以中止是因为他是一个推测副本或因为它所处的tasktracker失败，导致jobtracker将它上面的所有task attempt标记为killed。被终止的task attempt不会被计入任务运行尝试次数，因为尝试中止并不是任务的错。<br>2.tasktracker失败<br>    tasktracker由于崩溃或者运行过慢而失败，他将停止向jobtracker发送心跳（或很少发送心跳）。jobtracker注意已停止发送心跳的tasktracker（过期时间由参数mapred.tasktracker.expiry.interval设置，单位毫秒），并将它从等待调度的tasktracker池中移除。如果是未完成的作业，jobtracker会安排次tasktracker上已经运行成功的Map任务重新运行，因为此时reduce任务已无法访问（中间输出存放在失败的tasktracker的本地文件系统上）。<br>    即使tasktracker没有失败，也有可能被jobtracker列入黑名单。如果tasktracker上面的失败任务数量远远高于集群的平均失败任务次数，他就会被列入黑名单，被列入黑名单的tasktracker可以通过重启从jobtracker黑名单中移除。<br>3.jobtracker失败<br>    老版本的JobTracker失败属于单点故障，这种情况下作业注定失败。</p>
<h2 id="作业调度">作业调度</h2><p>早期作业调度FIFO：按作业提交顺序先进先出。可以设置优先级，通过设置mapred.job.priority属性或者JobClient的setJobPriority()方法制定优先级（优先级别：VERY_HIGH,HIGH,NORMAL,LOW,VERY_LOW）。注意FIFO调度算法不支持抢占（preemption）,所以高优先级作业仍然会被那些已经开始的长时间运行的低优先级作业所阻塞。<br>Fair Scheduler：目标是让每个用户公平地共享集群能力。当集群存在很多作业时，空闲的任务槽会以”让每个用户共享集群“的方式进行分配。默认每个用户都有自己的作业池。FairScheduler支持抢占，所以，如果一个池在特定的一段时间未得到公平地资源共享，它会终止池中得到过多的资源任务，以便把任务槽让给资源不足的池。FairScheduler是一个后续模块，使用它需要将其jar文件放在Hadoop的类路径下。可以通过参数map.red.jobtracker.taskScheduler属性配置（值为org.apache.hadoop.mapred.FairScheduler）<br>Capacity Scheduler：<br>集群由很多队列组成，每个队列都有一个分配能力，这一点与FairScheduler类似，只不过在每个队列内部，作业根据FIFO方式进行调度。本质上说，Capacity Scheduler允许用户或组织为每个用户模拟一个独立使用FIFO的集群。</p>
<h2 id="shuffle和排序">shuffle和排序</h2><p>MapReduce确保每个Reducer的输入都是按键排序的。系统执行排序的过程-将map输出作为输入传给reducer的过程称为shuffle。shuffle属于不断被优化和改进的代码库的一部分，从许多方面来看，shuffle是MapReduce的心脏。<br>整个shuffle的流程应该是这样：<br>    map结果划分partition  排序sort 分割spill   合并同一划分   合并同一划分  合并结果排序 reduce处理 输出<br>  <strong>Map端：</strong><br>    写入缓冲区：Map函数的输出，是由collector处理的，它并不是简单的将结果写到磁盘。它利用缓冲的方式写到内存，并处于效率的考虑进行预排序。每个map都有一个环形的内存缓冲区，用于任务输出，默认缓冲区大小为100MB（由参数io.sort.mb调整），一旦缓冲区内容达到阈值（默认0.8），后台进程边开始把内容写到磁盘（spill），在写磁盘过程中，map输出继续被写到缓冲区，但如果缓冲区被填满，map会阻塞知道写磁盘过程完成。写磁盘将按照轮询方式写到mapred.local.dir属性制定的作业特定子目录中。<br>    写出缓冲区：collect将缓冲区的内容写出时，会调用sortAndSpill函数，这个函数作用主要是创建spill文件，按照key值对数据进行排序，按照划分将数据写入文件，如果配置了combiner类，会先调用combineAndSpill函数再写文件。sortAndSpill每被调用一次，就会写一个spill文件。<br>    合并所有Map的spill文件：TaskTracker会在每个map任务结束后对所有map产生的spill文件进行merge，merge规则是根据分区将各个spill文件中数据同一分区中的数据合并在一起，并写入到一个已分区且排序的map输出文件中。待唯一的已分区且已排序的map输出文件写入最后一条记录后，map端的shuffle阶段就结束了。<br>    在写磁盘前，线程首先根据数据最终要传递到的reducer把数据划分成响应的分区（partition），在每个分区中，后台线程按键进行内排序，如果有一个combiner,它会在排序后的输出上运行。<br>    内存达到溢出写的阈值时，就会新建一个溢出写文件，因为map任务完成其最后一个输出记录之后，会有几个溢出写文件。在任务完成前，溢出写文件会被合并成一个已分区且已排序的输出文件。配置属性io.sort.facor控制一次最多能合并多少流，默认值是10。<br>    如果已经指定combiner,并且写次数至少为3（通过min.mum.spills.for.combine设置）时，则combiner就会在输出文件写到磁盘之前运行。运行combiner的意义在于使map输出更紧凑，舍得写到本地磁盘和传给reducer的数据更少。<br>    写磁盘时压缩：写磁盘时压缩会让写的速度更快，节约磁盘空间，并且减少传给reducer的数据量。默认情况下，输出是不压缩的，但可以通过设置mapred.compress.map.output值为true，就可以启用压缩。使用的压缩库是由mapred.map.output.compression.codec制定。<br>    reducer获得文件分区的工作线程：reducer通过http方式得到输出文件的分区，用于文件分区的工作线程数量由tracker.http.threads属性指定，此设置针对的是每个tasktracker，而不是每个map任务槽。默认值为40，在大型集群上此值可以根据需要而增加。</p>
<p><strong>Reduce端：</strong><br>    复制阶段：reduce会定期向JobTracker获取map的输出位置，一旦拿到输出位置，reduce就会从对应的TaskTracker上复制map输出到本地（如果map输出很小，则会被复制到TaskTracker节点的内存中，否则会被让如磁盘），而不会等到所有map任务结束（当然这个也有参数控制）。<br>    合并阶段：从各个TaskTracker上复制的map输出文件（无论在磁盘还是内存）进行整合，并维持数据原来的顺序。<br>    Reduce阶段：从合并的文件中顺序拿出一条数据进行reduce函数处理，然后将结果输出到本地HDFS。<br>    Map的输出文件位于运行map任务的tasktracker的本地磁盘，现在，tasktracker要为分区文件运行reduce任务。每个任务完成时间可能不同，但是只要有一个任务完成，reduce任务就开始复制其输出，这就是reduce任务的复制阶段（copy phase）。reduce任务有少量复制线程，因此能够并行取得map输出。默认值是5个线程，可以通过mapred.reduce.parallel.copies属性设置。<br>    Reducer如何得知从哪个tasktracker获得map输出：map任务完成后会通知其父tasktracker状态已更新，tasktracker进而通知（通过heart beat）jobtracker。因此，JobTracker就知道map输出和tasktracker之间的映射关系，reducer中的一个线程定期询问jobtracker以便获知map输出位置。由于reducer有可能失败，因此tasktracker并没有在第一个reducer检索到map输出时就立即从磁盘上删除它们，相反他会等待jobtracker告示它可以删除map输出时才删除，这是作业完成后最后执行的。<br>    如果map输出很小，则会被直接复制到reduce tasktracker的内存缓冲区（大小由mapred.job.shuffle.input.buffer.percent控制，占堆空间的百分比），否则，map输出被复制到磁盘。一旦内存缓冲区达到阈值大小（由mapred.iob.shuffle.merge.percent）<br>或达到map输出阈值大小（mapred.inmem.threadhold），则合并后溢出写到磁盘中。<br>    随着磁盘上副本增多，后台线程会将他们合并为更大的、排好序的文件。注意：为了合并，压缩的map输出必须在内存中被解压缩。<br>    排序阶段：复制阶段完成后，reduce任务会进入排序阶段，更确切的说是合并阶段，这个阶段将合并map输出，维持其顺序排列。合并是循环进行的，由合并因子决定每次合并的输出文件数量。但让有可能会产生中间文件。<br>    reduce阶段：在最后reduce阶段，会直接把排序好的文件输入reduce函数，不会对中间文件进行再合并，最后的合并即可来自内存，也可来自磁盘。此阶段的输出会直接写到文件系统，一般为hdfs。</p>
<p><strong>细节：</strong><br>这里合并是并非平均合并，比如有40个文件，合并因子为10，我们并不是每趟合并10个，合并四趟。而是第一趟合并4个，后三趟合并10，在最后一趟中4个已合并的文件和余下6个未合并会直接并入reduce。</p>
<h2 id="配置调优">配置调优</h2><p>调优总原则：在保证Map函数和Reduce函数能够得到足够内存的前提下，给shuffle过程提供更多的内存空间。<br>    1.编写map和reduce函数时尽量少占用内存空间。<br>    2.设置JVM内存大小（mapred.child.java.opts），任务节点内存大小应该尽量大（关于内存请见集群构建中的环境配置笔记）。<br>    3.Map端：避免多次溢出写磁盘。估算map输出大小，调整io.sort.mb（map输出内存缓冲区大小），如果可以，可增加其值。注意mapreduce计数器会记录作业在整个运行过程溢出写磁盘的记录数，这对调优很有帮助。<br>    4.Reduce端：中间数据全部驻留内存可获得最佳性能。如果reduce函数内存需求不大，那么可以把mapred.inmem.threadhold输出阈值调为0（即不写溢出），把mapred.job.shuffle.input.buffer.percent reduce 值设为1（即reduce内存缓冲区最大）会带来性能提升。<br>    5.提高Hadoop缓冲区：默认为4KB,应该在集群中增加这个值。</p>
<h2 id="任务的执行">任务的执行</h2><h3 id="推测执行">推测执行</h3><p>为了避免由于一个任务执行慢而是整个作业执行过慢的情况，hadoop 提供了一种推测执行的机制：即hadoop不会尝试诊断或修复执行慢的任务（其实不可能办到），而是在一个任务比预期慢的时候启动另一个相同的任务作为备份。<br>    一个任务和其推测任务任何一个成功完成，另一个就会中止。<br>    推测执行是一种优化措施，默认情况下推测执行是启用的。可以基于集群或基于每个作业，单独为map或reduce任务启用或禁用该项功能。mapred.map.tasks.speculative.execution  默认值为 true;mapred.reduce.tasks.speculative.execution 默认值为 true。推测执行目的是减少作业执行时间，但这是以集群效率为代价的，一般而言，集群管理员倾向于在集群上关闭该功能，而让用户根据个别需要而开启该功能。</p>
<h3 id="任务JVM重用">任务JVM重用</h3><p>Hadoop在自己的java虚拟机上运行任务，而且会为每个任务启动一个新的JVM，启动时间大约为1秒。参数mapred.job.reuse.jvm.num.tasks制定给定作业每个JVM运行任务的最大数，默认值为1，若设置为-1，则不限任务数量。JobConf中的setNumTasksToExecutePerJvm方法也可设置这个属性。计算超短任务或密集型任务也可以受益于JVM重用机制。共享JVM的另一个非常有用的地方是：作业个任务之间共享状态，任务可以较快的访问共享数据。<br>    跳过坏数据：<br>    通过开启skipnode来控制。</p>
<p>本节相关参数：</p>
<ol>
<li>mapred.submit.replication 运行作业资源的副本数。</li>
<li>mapred.reduce.task 作业的Reduce任务数量，可通过setNumReduceTasks()方法设置。</li>
<li>tasktracker任务槽数量。</li>
<li>心跳发送周期、任务进度报告周期、tasktracker进度报告周期、JobClient轮询周期。</li>
<li>job.end.notification.url 作业完成时客户端接收作业完成回调指令的参数。</li>
<li>本节会产生各种状态信息。</li>
<li>mapred.task.timeout 任务挂起的最大等待时间。</li>
<li>mapred.map.max.attempts 、mapred.reduce.max.attempts 任务失败最大尝试次数</li>
<li>mapred.max.map.failures.percent 、mapred.max.reduce.failures.percent 允许错误但不触发作业失败的任务数的百分比。</li>
<li>mapred.tasktracker.expiry.interval tasktracker向jobtracker发送心跳的过期时间，默认10分钟，单位毫秒。</li>
<li>mapred.job.priority 作业调度优先级。</li>
<li>map.red.jobtracker.taskScheduler 配置作业调度算法参数（值org.apache.hadoop.mapred.FairScheduler）。</li>
<li>io.sort.mb 默认map输出缓冲区大小参数 默认值100MB。</li>
<li>io.sort.spill.percent 写缓冲区内容阈值参数 默认值0.8。</li>
<li>mapred.local.dir map函数输出写磁盘目录。</li>
<li>io.sort.facor map溢出写文件一次被合并的数目 默认值是10(设置成100是很常见的)</li>
<li>mapred.compress.map.output Map输出写磁盘时是否启用压缩参数 默认值为false。</li>
<li>mapred.map.output.compression.codec Map输出磁盘启用压缩的压缩库</li>
<li>tracker.http.threads reducer 每个tasktracker获得文件分区的工作线程数量，针对一个tasktracker 默认值是40。</li>
<li>mapred.reduce.parallel.copies reduce任务复制map输出文件线程数量 默认值是5。</li>
<li>mapred.job.shuffle.input.buffer.percent shuffle复制阶段，分配给map 输出存缓冲区占堆栈空间的百分比，默认值0.7。</li>
<li>mapred.inmem.threadhold map输出阈值。</li>
<li>io.sort.record.percent 存储map输出记录边界的io.sort.mb的比例（内存缓冲区所占栈空间比例），剩余空间空间存储记录本身。</li>
<li>min.num.spills.for.combine 运行combiner所需要的最少溢出写文件数 默认值为3。</li>
<li>mapred.reduce.copy.backoff reducer获取一个map输出所花最大时间，单位是秒，默认值300</li>
<li>mapred.ijob.shufffle.merge.percent map输出缓冲区使用阈值的比例，启动合并输出 默认值为0.66.</li>
<li>mapred.inmem.merge.threadhold 启动map输出和磁盘溢出写过程的map输出阈值，默认值1000.</li>
<li>mapred.iob.reduce.input.buffer.percent 在reduce过程中，内从中保存map输出的空间占整个堆内存空间的比例。默认值为0。默认情况下，map输出都合并到磁盘上，以便为reducer提供尽可能多的内存，如果reducer需要的内存较少，可以增加此值来最小化磁盘访问次数。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.harrycode.com/2014/12/03/2014-12-03-to-hadoop-working-mechanism/" data-id="cibq3ipoq000zgh6ad1ut13h1" class="article-share-link">分享到</a>
      

      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-to-understand-mapreduce-data-flow" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/03/to-understand-mapreduce-data-flow/" class="article-date">
  <time datetime="2014-12-03T09:45:00.000Z" itemprop="datePublished">2014-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/03/to-understand-mapreduce-data-flow/">[转] 理解MapReduce数据流</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="先理解MapReduce作业组成">先理解MapReduce作业组成</h1><pre><code>一个完整的MapReduce作业称作job，它包括三部分：
<span class="bullet">1. </span>输入数据
<span class="bullet">2. </span>MapReduce程序
<span class="bullet">3. </span>配置信息     
</code></pre><p>  Hadoop工作时会将job分成若干个task：map任务和reduce任务<br>  有两类节点控制作业执行的过程：JobTracker和TaskTracker</p>
<pre><code>-<span class="ruby"> <span class="constant">JobTracker</span>：记录作业整体进度，对<span class="constant">TaskTracker</span>进行调度
</span>-<span class="ruby"> <span class="constant">TaskTracker</span>：执行task任务并向<span class="constant">JobTracker</span>汇报    </span>
</code></pre><h1 id="大块数据先流入map">大块数据先流入map</h1><p>  Hadoop会将输入数据划分成等长的数据块，成为数据分片。Hadoop会为每个分片构建一个map任务。并行的处理分片时间肯定会少于处理整个大数据块的时间，但由于各个节点性能及作业运行情况的不同，每个分片的处理时间可能不一样，因此，把数据分片切分的更细可以得到更好的负载均衡。<br>  但另一方面，分片太小的话，管理分片和构建map任务的时间将会增多。因此，需要在hadoop分片大小和处理分片时间之间做一个权衡。对大多数作业来说，一个分片大小为64MB比较合适，其实，Hadoop的默认块大小也是64MB。<br>  我们上面看到了hadoop的数据块大小与最佳分片大小相同，这样的话，数据分片就不容易跨数据块存储，因此，一个map任务的输入分片便可以直接读取本地数据块，这就避免了再从其它节点读取分片数据，从而节省了网络开销。<br>  map的任务输出是写入到本地磁盘而非HDFS的。那么为什么呢？因为map任务输出的是中间结果，一旦map任务完成即会被删除，如果把它存入HDFS中并实现备份容错，未免有点大题小做。如果一个map任务失败，hadoop会再另一个节点重启map一个map任务。</p>
<h1 id="数据从map流入reduce">数据从map流入reduce</h1><p>  而reduce任务并不具备数据本地化优势——单个reduce任务的输入通常来自所有mapper输出。一般排序过的map输出需要通过网络传输发送到运行reduce任务的节点，并在reduce端进行合并。reduce的输出通常需要存储到HDFS中以实现可靠存储。每个reduce输出HDFS块第一个复本会存储在本地节点，而其它复本则存储到其它节点，因此reduce输出也需要占用网络带宽。</p>
<p>  如下图：一个reduce任务的MapReduce任务数据流<br><img class="center" src="http://img.blog.csdn.net/20141201195323354?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p>  reduce任务的数量并非由输入数据大小决定，而是特别指定。如有多个reduce任务，则每个map任务都会对其输出进行分区（partition），因为每个reduce任务会建一个分区。相同键的记录都会被partition到同一个分区中。具体的分区方式由分区函数来控制，一般通过hash函数来分区。<br>  我们把map任务和reduce任务之间的数据流称为shuffle，因为每个reduce任务的输入都来自多个map任务，因此，这个阶段比较复杂，而shuffle过程中的参数调整对job运行的总时间是有非常大的影响的，一般MapReduce的调优主要就是调整shuffle阶段的参数。</p>
<p>如下图：多个reduce任务的数据流<br><img class="center" src="http://img.blog.csdn.net/20141201195403671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<h1 id="如何减少从map到reduce的数据量">如何减少从map到reduce的数据量</h1><p>  集群上的可用带宽限制了MapReduce的作业数量，因为map的中间结果传递给reduce是要经过网络传输的，因此最重要的一点就是尽量减少map和reduce任务间传输的数据量。不过，Hadoop允许用户针对map任务的输出指定一个合并函数（combiner），用合并函数的输出作为reduce函数的输入，但需要注意，合并函数的运用不应该改变reduce函数的计算结果。</p>
<p>  例如有两个map的输出分别是map1={0,20,10};map2={15,25}，求最大值，我们可以对先每个map的数据的数据进行合并，合并完成之后再传输给reducer：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map1=&#123;<span class="number">0</span>,<span class="number">20</span>,<span class="number">10</span>&#125;-&gt;combiner-&gt;&#123;<span class="number">20</span>&#125;;</span><br><span class="line">map2=&#123;<span class="number">15</span>,<span class="number">25</span>&#125;-&gt;combiner-&gt;&#123;<span class="number">25</span>&#125;;</span><br><span class="line">reducer-&gt;&#123;<span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>  即 max(0,20,10,15,25)=max(max(0,20,10),max(15,25))=25</p>
<p>如下图：将combiner后的输出作为reducer的输入<br><img class="center" src="http://img.blog.csdn.net/20141201195417081?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p>  但需要特别注意的是，并不是任何场景都是可以用combiner的，比如把上面的例子改成求平均值：<br>    combiner后的reducer的结果:       <code>avg(avg(0,20,10),avg(15,25))=avg(10,20)=15;</code><br>    没有进行combiner的reducer结果：  <code>avg(0,20,10,15,25)=14;</code></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.harrycode.com/2014/12/03/to-understand-mapreduce-data-flow/" data-id="cibq3ipo30007gh6aqtyo6fe0" class="article-share-link">分享到</a>
      

      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-to-briefly-introduce-each-major-module-of-hadoop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/03/to-briefly-introduce-each-major-module-of-hadoop/" class="article-date">
  <time datetime="2014-12-03T09:29:00.000Z" itemprop="datePublished">2014-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/03/to-briefly-introduce-each-major-module-of-hadoop/">[转] 简要介绍Hadoop的各个主要模块</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>先从概念层次介绍下Hadoop的各个组件，下一部分会深入Hadoop的每个组件，并从实战层次讲解。</p>
<h1 id="一、Hadoop构造模块">一、Hadoop构造模块</h1><pre><code>运行Hadoop的意思其实就是运行一组守护进程（daemons），每个进程都有各自的角色，有的仅运行在单个服务器上，有的则运行在集群多个服务器上，它们包括：
</code></pre><p>NameNode<br>Secondary NameNode<br>DataNode<br>JobTracker<br>TaskTracker<br>     Hadoop是一个分布式存储与计算系统，分布式存储部分是HDFS，分布式计算部分是MapReduce，它们都是遵循主/从（Master/Slave)结构，上面前3个组件属于分布式存储部分，后面2个组件属于分布式计算部分，下面详细介绍一下它们。</p>
<h1 id="二、NameNode">二、NameNode</h1><pre><code><span class="comment">前面说了，NameNode属于HDFS</span><span class="string">,</span><span class="comment">它位于HDSF的主端，由它来指导DataNode执行底层I/O任务。NameNode相当于HDFS的书记员，它会跟踪文件如何被分割成文件块，而这些块又是被哪些节点存储，以及分布式文件系统整体运行状态是否正常等。</span>
<span class="comment">运行NameNode会消耗大量内存和IO资源，因此为减轻机器负载，驻留NameNode的服务器通常不会存储用户数据或者进行MapReduce计算任务，这也就意味着一台NameNode服务器不会同时是DataNode或者TaskTracker服务器。</span>
<span class="comment">不过NameNode的重要性也带来了一个负面影响</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">单点故障。对于其他任何守护进程，其驻留节点发生软件或硬件故障，Hadoop集群还可平稳运行，但是对于NameNode来说，则不可以。不过后面版本（2</span><span class="string">.</span><span class="comment">0以后的版本）已经解决此问题。</span>
</code></pre><h1 id="三、DataNode">三、DataNode</h1><pre><code>集群中每一个从节点都会驻留一个DataNode的守护进程，用来将HDFS数据库写入或读取到本地文件系统中。当对HDFS文件进行读写时，文件会被分割成多个块，有NameNode告知客户端每个数据驻留在哪个DataNode，客户端直接与DataNode进行通信，DataNode还会与其它DataNode通信，复制这些块以实现冗余。
</code></pre><p><img class="center" src="http://img.blog.csdn.net/20140718163718921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p>NameNode跟踪源数据，DataNode提供数据块的备份存储并持续不断地向NameNode报告，以保持元数据最新状态。</p>
<h1 id="四、_Secondary_NameNode">四、 Secondary NameNode</h1><pre><code>SNN是一个监测HDFS的辅助进程，它只与NameNode进程通信，根据集群配置时间间隔获取HDFS元数据快照，我们知道HDFS有单点故障，SNN快照有助于减少宕机而导致的数据丢失风险，其一般也单独占一台服务器。
</code></pre><h1 id="五、_JobTracker">五、 JobTracker</h1><pre><code>它是应用程序和Hadoop之间的纽带，监控MapReduce作业执行过程，一旦提交代码到集群，JobTracker就会确定执行计划，包括决定处理哪些文件、为不同的任务分配节点以及监控所有任务运行。每个集群只有一个JobTracker进程，一般运行在主节点。
</code></pre><h1 id="六、_TaskTracker">六、 TaskTracker</h1><pre><code>TaskTracker管理各个任务在从节点上的执行情况。它负责执行有JobTracker分配的单项任务，虽然每个从节点只有一个TaskTracker运行，但每个TaskTracker可以生产多个JVM来并行地处理多<span class="keyword">Map</span>或<span class="keyword">Reduce</span>任务。TaskTracker的一个职责是不断的与JobTracker通信，即“心跳”。
</code></pre><p>下面再来整体看一下整个Hadoop拓扑结构</p>
<p>下面就是一个典型的Hadoop拓扑图，主动结构，NameNode和JobTracker位于主端，DataNode和TaskTracker位于从端。<br><img class="center" src="http://img.blog.csdn.net/20140718163814687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p>客户端向JobTracker发送Job任务，JobTracker会把Job切分，并分配不同的Map和Reduce任务到每一台机器。<br><img class="center" src="http://img.blog.csdn.net/20140718164110271?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.harrycode.com/2014/12/03/to-briefly-introduce-each-major-module-of-hadoop/" data-id="cibq3ipo9000agh6arrd8roy5" class="article-share-link">分享到</a>
      

      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-to-to-quickly-grasp-mapreduce" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/03/to-to-quickly-grasp-mapreduce/" class="article-date">
  <time datetime="2014-12-03T07:50:00.000Z" itemprop="datePublished">2014-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/03/to-to-quickly-grasp-mapreduce/">[转] 快速理解MapReduce</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1_什么是MapReduce？">1 什么是MapReduce？</h1><p>　　Map本意可以理解为地图，映射（面向对象语言都有Map集合），这里我们可以理解为从现实世界获得或产生映射。Reduce本意是减少的意思，这里我们可以理解为归并前面Map产生的映射。</p>
<h1 id="2_MapReduce的编程模型">2 MapReduce的编程模型</h1><p>　　按照google的MapReduce论文所说的，MapReduce的编程模型的原理是：利用一个输入key/value对集合来产生一个输出的key/value对集合。MapReduce库的用户用两个函数表达这个计算：Map和Reduce。用户自定义的Map函数接受一个输入的key/value对值，然后产生一个中间key/value对值的集合。MapReduce库把所有具有相同中间key值的中间value值集合在一起后传递给Reduce函数。用户自定义的Reduce函数接受一个中间key的值和相关的一个value值的集合。Reduce函数合并这些value值，形成一个较小的value值的集合。</p>
<h1 id="3_MapReduce实现">3 MapReduce实现</h1><p>　　通过将Map调用的输入数据自动分割为M个数据片段的集合，Map调用被分布到多台机器上执行。输入的数据片段能够在不同的机器上并行处理。使用分区函数将Map调用产生的中间key值分成R个不同分区（例如，hash(key) mod R），Reduce调用也被分布到多台机器上执行。分区数量（R）和分区函数由用户来指定。</p>
<p>　　MapReduce实现的大概过程如下：</p>
<p>　　1.用户程序首先调用的MapReduce库将输入文件分成M个数据片度，每个数据片段的大小一般从16MB到64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在集群中创建大量的程序副本。</p>
<p>　　2.这些程序副本中的有一个特殊的程序master。副本中其它的程序都是worker程序，由master分配任务。有M个Map任务和R个Reduce任务将被分配，master将一个Map任务或Reduce任务分配给一个空闲的worker。 </p>
<p>　　3.被分配了map任务的worker程序读取相关的输入数据片段，从输入的数据片段中解析出key/value对，然后把key/value对传递给用户自定义的Map函数，由Map函数生成并输出的中间key/value对，并缓存在内存中。 </p>
<p>　　4.缓存中的key/value对通过分区函数分成R个区域，之后周期性的写入到本地磁盘上，会产生R个临时文件。缓存的key/value对在本地磁盘上的存储位置将被回传给master，由master负责把这些存储位置再传送给Reduce worker。 </p>
<p>　　5.当Reduce worker程序接收到master程序发来的数据存储位置信息后，使用RPC从Map worker所在主机的磁盘上读取这些缓存数据。当Reduce worker读取了所有的中间数据（这个时候所有的Map任务都执行完了）后，通过对key进行排序后使得具有相同key值的数据聚合在一起。由于许多不同的key值会映射到相同的Reduce任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。 </p>
<p>　　6.Reduce worker程序遍历排序后的中间数据，对于每一个唯一的中间key值，Reduce worker程序将这个key值和它相关的中间value值的集合（这个集合是由Reduce worker产生的，它存放的是同一个key对应的value值）传递给用户自定义的Reduce函数。Reduce函数的输出被追加到所属分区的输出文件。 </p>
<p>　　上面过程中的排序很容易理解，关键是分区，这一步最终决定该键值对未来会交给哪个reduce任务，如统计单词出现的次数可以用前面说的hash(key) mod R来分区，如果是对数据进行排序则应该根据key的分布进行分区。</p>
<p>图1 MapReduce过程<br><img class="center" src="http://img.blog.csdn.net/20141201200156533?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<h1 id="4_例子">4 例子</h1><p>　　假设我们需要处理一批有关天气的数据，其格式如下： 按照ASCII码存储，每行一条记录，每一行字符从0开始计数，第15个到第18个字符为年，第25个到第29个字符为温度，其中第25位是符号+/-，现在需要统计出每年的最高温度。</p>
<p>　　0067011990999991950051507+0000+<br>　　0043011990999991950051512+0022+<br>　　0043011990999991950051518-0011+<br>　　0043012650999991949032412+0111+<br>　　0043012650999991949032418+0078+<br>　　0067011990999991937051507+0001+<br>　　0043011990999991937051512-0002+<br>　　0043011990999991945051518+0001+<br>　　0043012650999991945032412+0002+<br>　　0043012650999991945032418+0078+ </p>
<p>　　MapReduce主要包括两个步骤：Map和Reduce 每一步都有key/value对作为输入和输出： </p>
<p>　　Map阶段的key/value对的格式是由输入的格式所决定的，如果是默认的TextInputFormat，则每行作为一个记录进程处理，其中key为此行的开头相对于文件的起始位置，value就是此行的字符文本，Map阶段的输出的key/value对的格式必须同Reduce阶段的输入key/value对的格式相对应</p>
<p>　　对于上面的例子，在map过程，输入的key-value对如下：<br>　　(0 ,0067011990999991950051507+0000+)<br>　　(1 ,0043011990999991950051512+0022+)<br>　　(2 ,0043011990999991950051518-0011+)<br>　　(3 ,0043012650999991949032412+0111+)<br>　　(4 ,0043012650999991949032418+0078+)<br>　　(5 ,0067011990999991937051507+0001+)<br>　　(6 ,0043011990999991937051512-0002+)<br>　　(7 ,0043011990999991945051518+0001+)<br>　　(8 ,0043012650999991945032412+0002+)<br>　　(9 ,0043012650999991945032418+0078+) </p>
<p>　　将上面的数据作为用户编写的map函数的输入，通过对每一行字符串的解析，得到年/温度的key/value对作为输出：<br>　　(1950, 0)<br>　　(1950, 22)<br>　　(1950, -11)<br>　　(1949, 111)<br>　　(1949, 78)<br>　　(1937, 1)<br>　　(1937, -2)<br>　　(1945, 1)<br>　　(1945, 2)<br>　　(1945, 78) </p>
<p>　　在Reduce过程，将map过程中的输出，按照相同的key将value放到同一个列表中作为用户写的reduce函数的输入<br>　　(1950, [0, 22, –11])<br>　　(1949, [111, 78])<br>　　(1937, [1, -2])<br>　　(1945, [1, 2, 78]) </p>
<p>　　在Reduce过程中，在列表中选择出最大的温度，将年/最大温度的key/value作为输出：<br>　　(1950, 22)<br>　　(1949, 111)<br>　　(1937, 1)<br>　　(1945, 78) </p>
<p>　　其逻辑过程可用如下图表示：<br><img class="center" src="http://img.blog.csdn.net/20141201200237609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.harrycode.com/2014/12/03/to-to-quickly-grasp-mapreduce/" data-id="cibq3ipo50008gh6ati6ipwvl" class="article-share-link">分享到</a>
      

      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-to-to-quickly-grasp-mapreduce-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/03/to-to-quickly-grasp-mapreduce-1/" class="article-date">
  <time datetime="2014-12-03T07:50:00.000Z" itemprop="datePublished">2014-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/03/to-to-quickly-grasp-mapreduce-1/">[转] 快速理解MapReduce</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1_什么是MapReduce？">1 什么是MapReduce？</h1><p>　　Map本意可以理解为地图，映射（面向对象语言都有Map集合），这里我们可以理解为从现实世界获得或产生映射。Reduce本意是减少的意思，这里我们可以理解为归并前面Map产生的映射。</p>
<h1 id="2_MapReduce的编程模型">2 MapReduce的编程模型</h1><p>　　按照google的MapReduce论文所说的，MapReduce的编程模型的原理是：利用一个输入key/value对集合来产生一个输出的key/value对集合。MapReduce库的用户用两个函数表达这个计算：Map和Reduce。用户自定义的Map函数接受一个输入的key/value对值，然后产生一个中间key/value对值的集合。MapReduce库把所有具有相同中间key值的中间value值集合在一起后传递给Reduce函数。用户自定义的Reduce函数接受一个中间key的值和相关的一个value值的集合。Reduce函数合并这些value值，形成一个较小的value值的集合。</p>
<h1 id="3_MapReduce实现">3 MapReduce实现</h1><p>　　通过将Map调用的输入数据自动分割为M个数据片段的集合，Map调用被分布到多台机器上执行。输入的数据片段能够在不同的机器上并行处理。使用分区函数将Map调用产生的中间key值分成R个不同分区（例如，hash(key) mod R），Reduce调用也被分布到多台机器上执行。分区数量（R）和分区函数由用户来指定。</p>
<p>　　MapReduce实现的大概过程如下：</p>
<p>　　1.用户程序首先调用的MapReduce库将输入文件分成M个数据片度，每个数据片段的大小一般从16MB到64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在集群中创建大量的程序副本。</p>
<p>　　2.这些程序副本中的有一个特殊的程序master。副本中其它的程序都是worker程序，由master分配任务。有M个Map任务和R个Reduce任务将被分配，master将一个Map任务或Reduce任务分配给一个空闲的worker。 </p>
<p>　　3.被分配了map任务的worker程序读取相关的输入数据片段，从输入的数据片段中解析出key/value对，然后把key/value对传递给用户自定义的Map函数，由Map函数生成并输出的中间key/value对，并缓存在内存中。 </p>
<p>　　4.缓存中的key/value对通过分区函数分成R个区域，之后周期性的写入到本地磁盘上，会产生R个临时文件。缓存的key/value对在本地磁盘上的存储位置将被回传给master，由master负责把这些存储位置再传送给Reduce worker。 </p>
<p>　　5.当Reduce worker程序接收到master程序发来的数据存储位置信息后，使用RPC从Map worker所在主机的磁盘上读取这些缓存数据。当Reduce worker读取了所有的中间数据（这个时候所有的Map任务都执行完了）后，通过对key进行排序后使得具有相同key值的数据聚合在一起。由于许多不同的key值会映射到相同的Reduce任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。 </p>
<p>　　6.Reduce worker程序遍历排序后的中间数据，对于每一个唯一的中间key值，Reduce worker程序将这个key值和它相关的中间value值的集合（这个集合是由Reduce worker产生的，它存放的是同一个key对应的value值）传递给用户自定义的Reduce函数。Reduce函数的输出被追加到所属分区的输出文件。 </p>
<p>　　上面过程中的排序很容易理解，关键是分区，这一步最终决定该键值对未来会交给哪个reduce任务，如统计单词出现的次数可以用前面说的hash(key) mod R来分区，如果是对数据进行排序则应该根据key的分布进行分区。</p>
<p>图1 MapReduce过程<br><img class="center" src="http://img.blog.csdn.net/20141201200156533?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<h1 id="4_例子">4 例子</h1><p>　　假设我们需要处理一批有关天气的数据，其格式如下： 按照ASCII码存储，每行一条记录，每一行字符从0开始计数，第15个到第18个字符为年，第25个到第29个字符为温度，其中第25位是符号+/-，现在需要统计出每年的最高温度。</p>
<p>　　0067011990999991950051507+0000+<br>　　0043011990999991950051512+0022+<br>　　0043011990999991950051518-0011+<br>　　0043012650999991949032412+0111+<br>　　0043012650999991949032418+0078+<br>　　0067011990999991937051507+0001+<br>　　0043011990999991937051512-0002+<br>　　0043011990999991945051518+0001+<br>　　0043012650999991945032412+0002+<br>　　0043012650999991945032418+0078+ </p>
<p>　　MapReduce主要包括两个步骤：Map和Reduce 每一步都有key/value对作为输入和输出： </p>
<p>　　Map阶段的key/value对的格式是由输入的格式所决定的，如果是默认的TextInputFormat，则每行作为一个记录进程处理，其中key为此行的开头相对于文件的起始位置，value就是此行的字符文本，Map阶段的输出的key/value对的格式必须同Reduce阶段的输入key/value对的格式相对应</p>
<p>　　对于上面的例子，在map过程，输入的key-value对如下：<br>　　(0 ,0067011990999991950051507+0000+)<br>　　(1 ,0043011990999991950051512+0022+)<br>　　(2 ,0043011990999991950051518-0011+)<br>　　(3 ,0043012650999991949032412+0111+)<br>　　(4 ,0043012650999991949032418+0078+)<br>　　(5 ,0067011990999991937051507+0001+)<br>　　(6 ,0043011990999991937051512-0002+)<br>　　(7 ,0043011990999991945051518+0001+)<br>　　(8 ,0043012650999991945032412+0002+)<br>　　(9 ,0043012650999991945032418+0078+) </p>
<p>　　将上面的数据作为用户编写的map函数的输入，通过对每一行字符串的解析，得到年/温度的key/value对作为输出：<br>　　(1950, 0)<br>　　(1950, 22)<br>　　(1950, -11)<br>　　(1949, 111)<br>　　(1949, 78)<br>　　(1937, 1)<br>　　(1937, -2)<br>　　(1945, 1)<br>　　(1945, 2)<br>　　(1945, 78) </p>
<p>　　在Reduce过程，将map过程中的输出，按照相同的key将value放到同一个列表中作为用户写的reduce函数的输入<br>　　(1950, [0, 22, –11])<br>　　(1949, [111, 78])<br>　　(1937, [1, -2])<br>　　(1945, [1, 2, 78]) </p>
<p>　　在Reduce过程中，在列表中选择出最大的温度，将年/最大温度的key/value作为输出：<br>　　(1950, 22)<br>　　(1949, 111)<br>　　(1937, 1)<br>　　(1945, 78) </p>
<p>　　其逻辑过程可用如下图表示：<br><img class="center" src="http://img.blog.csdn.net/20141201200237609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.harrycode.com/2014/12/03/to-to-quickly-grasp-mapreduce-1/" data-id="cibq3ipo70009gh6ax3h4b4h7" class="article-share-link">分享到</a>
      

      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-today-is-my-birthday-and-my-country" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/06/26/today-is-my-birthday-and-my-country/" class="article-date">
  <time datetime="2014-06-26T08:58:00.000Z" itemprop="datePublished">2014-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/26/today-is-my-birthday-and-my-country/">今天是我的生日,我的祖国</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天是我的生日，我的祖国。</p>
<p>过去的一年里发生了很多，失去了至亲，换了房子搬了家，接来了娘，换了工作。</p>
<p>青春的颜色逐渐褪去殆尽，余下的是生活的琐碎和每日回家的温暖。</p>
<p>很难注名的去感谢谁谁谁，但希望你们一直再我身边，原谅着我的任性与偏执，理解着我的执着与坚持。</p>
<p>许愿这么老土的事情就留给别人吧，有些事情要亲力亲为才有意义。</p>
<p>如果一定要给过去的一岁填个横批。</p>
<p>我希望是——不曾虚度。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.harrycode.com/2014/06/26/today-is-my-birthday-and-my-country/" data-id="cibq3ipo10006gh6a6kj853j3" class="article-share-link">分享到</a>
      

      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx-monitoring-tool-ngxtop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/20/nginx-monitoring-tool-ngxtop/" class="article-date">
  <time datetime="2014-05-20T04:01:00.000Z" itemprop="datePublished">2014-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/20/nginx-monitoring-tool-ngxtop/">Nginx监控利器 Ngxtop</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介">简介</h1><p>Nginx 作为新一代的WebServer + ProxyServer， 以其优秀的并发能力，已被广泛接受。使用之广，直逼界内前辈 Apache。今天我们介绍一款Nginx的监控工具 <a href="https://github.com/lebinh/ngxtop#rd" target="_blank" rel="external">Ngxtop</a>，这款工具基于AccessLog的解析，为我们提供非常友好的统计方式，统计各个页面的request_path, remote_addr, status等，并基于字段order/group，监控起来自然是比awk这些工具要方便许多。<strong>附官方Demo：</strong></p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ngxtop</span><br><span class="line">running for <span class="number">411</span> seconds, <span class="number">64332</span> records processed: <span class="number">156.60</span> req/sec</span><br><span class="line"></span><br><span class="line">Summary:</span><br><span class="line"><span class="string">|   count |   avg_bytes_sent |   2xx |   3xx |   4xx |   5xx |</span></span><br><span class="line"><span class="string">|---------+------------------+-------+-------+-------+-------|</span></span><br><span class="line"><span class="string">|   64332 |         2775.251 | 61262 |  2994 |    71 |     5 |</span></span><br><span class="line"></span><br><span class="line">Detailed:</span><br><span class="line"><span class="string">| request_path                             |   count |   avg_bytes_sent |   2xx |   3xx |   4xx |   5xx |</span></span><br><span class="line"><span class="string">|------------------------------------------+---------+------------------+-------+-------+-------+-------|</span></span><br><span class="line"><span class="string">| /abc/xyz/xxxx                            |   20946 |          434.693 | 20935 |     0 |    11 |     0 |</span></span><br><span class="line"><span class="string">| /xxxxx.json                              |    5633 |         1483.723 |  5633 |     0 |     0 |     0 |</span></span><br><span class="line"><span class="string">| /xxxxx/xxx/xxxxxxxxxxxxx                 |    3629 |         6835.499 |  3626 |     0 |     3 |     0 |</span></span><br><span class="line"><span class="string">| /xxxxx/xxx/xxxxxxxx                      |    3627 |        15971.885 |  3623 |     0 |     4 |     0 |</span></span><br><span class="line"><span class="string">| /xxxxx/xxx/xxxxxxx                       |    3624 |         7830.236 |  3621 |     0 |     3 |     0 |</span></span><br><span class="line"><span class="string">| /static/js/minified/utils.min.js         |    3031 |         1781.155 |  2104 |   927 |     0 |     0 |</span></span><br><span class="line"><span class="string">| /static/js/minified/xxxxxxx.min.v1.js    |    2889 |         2210.235 |  2068 |   821 |     0 |     0 |</span></span><br><span class="line"><span class="string">| /static/tracking/js/xxxxxxxx.js          |    2594 |         1325.681 |  1927 |   667 |     0 |     0 |</span></span><br><span class="line"><span class="string">| /xxxxx/xxx.html                          |    2521 |          573.597 |  2520 |     0 |     1 |     0 |</span></span><br><span class="line"><span class="string">| /xxxxx/xxxx.json                         |    1840 |          800.542 |  1839 |     0 |     1 |     0 |</span></span><br></pre></td></tr></table></figure>
<h1 id="安装">安装</h1><p>Ngxtop 是基于Python编写的，依赖Python，通过pip即可安装。一般服务器都会遇装Python，只是版本高低各有不同。安装Python的文章可以随手找到，不再赘述。</p>
<h2 id="pip">pip</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget --<span class="keyword">no</span>-check-certificate http<span class="variable">s:</span>//bootstrap.pypa.io/<span class="built_in">get</span>-pip.<span class="keyword">py</span></span><br><span class="line"><span class="keyword">python</span> <span class="built_in">get</span>-pip.<span class="keyword">py</span></span><br></pre></td></tr></table></figure>
<h2 id="Ngxtop">Ngxtop</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">beta-<span class="number">01</span>#  pip install ngxtop</span><br><span class="line"></span><br><span class="line">Downloading/unpacking ngxtop</span><br><span class="line">  Downloading ngxtop-<span class="number">0.0</span>.2-py2.py3-none-any.whl</span><br><span class="line">Downloading/unpacking pyparsing (from ngxtop)</span><br><span class="line">  Downloading pyparsing-<span class="number">2.0</span>.2.tar.gz (<span class="number">1.1</span>MB): <span class="number">1.1</span>MB downloaded</span><br><span class="line">  Running setup.py (<span class="string">path:</span><span class="regexp">/tmp/</span>pip_build_root<span class="regexp">/pyparsing/</span>setup.py) egg_info <span class="keyword">for</span> <span class="keyword">package</span> pyparsing</span><br><span class="line">Downloading/unpacking docopt (from ngxtop)</span><br><span class="line">  Downloading docopt-<span class="number">0.6</span>.1.tar.gz</span><br><span class="line">  Running setup.py (<span class="string">path:</span><span class="regexp">/tmp/</span>pip_build_root<span class="regexp">/docopt/</span>setup.py) egg_info <span class="keyword">for</span> <span class="keyword">package</span> docopt</span><br><span class="line">Downloading/unpacking tabulate (from ngxtop)</span><br><span class="line">  Downloading tabulate-<span class="number">0.7</span>.2.tar.gz</span><br><span class="line">  Running setup.py (<span class="string">path:</span><span class="regexp">/tmp/</span>pip_build_root<span class="regexp">/tabulate/</span>setup.py) egg_info <span class="keyword">for</span> <span class="keyword">package</span> tabulate</span><br><span class="line">Installing collected <span class="string">packages:</span> ngxtop, pyparsing, docopt, tabulate</span><br><span class="line">  Running setup.py install <span class="keyword">for</span> pyparsing</span><br><span class="line">  Running setup.py install <span class="keyword">for</span> docopt</span><br><span class="line">  Running setup.py install <span class="keyword">for</span> tabulate</span><br><span class="line">Successfully installed ngxtop pyparsing docopt tabulate</span><br><span class="line">Cleaning up...</span><br></pre></td></tr></table></figure>
<h1 id="使用">使用</h1><p>老规矩，看看help</p>
<p>Options:<br><code>-l &lt;file&gt;, --access-log &lt;file&gt;  access log file to parse.</code>  #指定access log<br><code>-f &lt;format&gt;, --log-format &lt;format&gt;  log format as specify in log_format directive. [default: combined]</code> #指定 log format<br><code>--no-follow  ngxtop default behavior is to ignore current lines in log and only watch for new lines as they are written to the access log. Use this flag to tell ngxtop to process the current content of the access log instead.</code> #ngxtop默认会对accesslog的新增行进行统计， 通过这个选项可以让ngxtop统计旧log<br><code>-t &lt;seconds&gt;, --interval &lt;seconds&gt;  report interval when running in follow mode [default: 2.0]</code><br><code>-g &lt;var&gt;, --group-by &lt;var&gt;  group by variable [default: request_path]</code> # 基于字段分组<br><code>-w &lt;var&gt;, --having &lt;expr&gt;  having clause [default: 1]</code> # 分组之后再筛选<br><code>-o &lt;var&gt;, --order-by &lt;var&gt;  order of output for default query [default: count]</code> # 排序字段<br><code>-n &lt;number&gt;, --limit &lt;number&gt;  limit the number of records included in report for top command [default: 10]</code> #默认显示前多少条<br><code>-a &lt;exp&gt; ..., --a &lt;exp&gt; ...  add exp (must be aggregation exp: sum, avg, min, max, etc.) into output</code> # 对输出字段做附加条件 sum/avg/min/max 可选</p>
<p><code>-v, --verbose  more verbose output</code><br><code>-d, --debug  print every line and parsed record</code><br><code>-h, --help  print this help message.</code><br><code>--version  print version information.</code></p>
<p>Advanced / experimental options:<br><code>-c &lt;file&gt;, --config &lt;file&gt;  allow ngxtop to parse nginx config file for log format and location.</code> # 指定nginx config文件，ngxtop 会自动解析配置文件，分析出access log的位置以及格式<br><code>-i &lt;filter-expression&gt;, --filter &lt;filter-expression&gt;  filter in, records satisfied given expression are processed.</code><br><code>-p &lt;filter-expression&gt;, --pre-filter &lt;filter-expression&gt; in-filter expression to check in pre-parsing phase.</code></p>
<p>一些demo<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Examples:</span><br><span class="line">    <span class="keyword">All</span> examples read nginx config <span class="keyword">file</span> <span class="keyword">for</span> <span class="keyword">access</span> log location <span class="keyword">and</span> format.</span><br><span class="line">    <span class="keyword">If</span> you want <span class="keyword">to</span> specify the <span class="keyword">access</span> log <span class="keyword">file</span> <span class="keyword">and</span> / <span class="keyword">or</span> log format, <span class="keyword">use</span> the -f <span class="keyword">and</span> -a options.</span><br><span class="line"></span><br><span class="line">    <span class="string">"top"</span> like view <span class="keyword">of</span> nginx requests</span><br><span class="line">    $ ngxtop</span><br><span class="line"></span><br><span class="line">    Top <span class="number">10</span> requested path <span class="keyword">with</span> status <span class="number">404</span>:</span><br><span class="line">    $ ngxtop top request_path <span class="comment">--filter 'status == 404'</span></span><br><span class="line"></span><br><span class="line">    Top <span class="number">10</span> requests <span class="keyword">with</span> highest total bytes sent</span><br><span class="line">    $ ngxtop <span class="comment">--order-by 'avg(bytes_sent) * count'</span></span><br><span class="line"></span><br><span class="line">    Top <span class="number">10</span> remote address, e.g., who<span class="attribute">'s</span> hitting you the most</span><br><span class="line">    $ ngxtop <span class="comment">--group-by remote_addr</span></span><br><span class="line"></span><br><span class="line">    Print requests <span class="keyword">with</span> <span class="number">4</span>xx <span class="keyword">or</span> <span class="number">5</span>xx status, together <span class="keyword">with</span> status <span class="keyword">and</span> http referer</span><br><span class="line">    $ ngxtop -i <span class="attribute">'status</span> &gt;= <span class="number">400</span>' print request status http_referer</span><br><span class="line"></span><br><span class="line">    Average <span class="keyword">body</span> bytes sent <span class="keyword">of</span> <span class="number">200</span> responses <span class="keyword">of</span> requested path <span class="keyword">begin</span> <span class="keyword">with</span> <span class="attribute">'foo</span>':</span><br><span class="line">    $ ngxtop avg bytes_sent <span class="comment">--filter 'status == 200 and request_path.startswith("foo")'</span></span><br><span class="line"></span><br><span class="line">    Analyze apache <span class="keyword">access</span> log from remote machine using <span class="attribute">'common</span>' log format</span><br><span class="line">    $ ssh remote tail -f /var/log/apache2/<span class="keyword">access</span>.log | ngxtop -f common</span><br></pre></td></tr></table></figure></p>
<p>实际使用下来还是很方便的，可以很方便看到403／500／404等情况，有利于我们掌握当前的服务质量。</p>
<p>Enjoy~</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.harrycode.com/2014/05/20/nginx-monitoring-tool-ngxtop/" data-id="cibq3ipoc000egh6ai8ne91s2" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tool/">Tool</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux-server-system-monitor-tool-collecting" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/15/linux-server-system-monitor-tool-collecting/" class="article-date">
  <time datetime="2014-05-15T08:50:00.000Z" itemprop="datePublished">2014-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/15/linux-server-system-monitor-tool-collecting/">Linux 服务端系统监控工具大起底</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言">前言</h1><p>没有好声音，再好的戏也出不来。<br>没有好工具，再好的服务器也出不来。</p>
<p>最近一直在做一些服务端系统调优的工作，频繁的和各种监控工具打交到。很多工具以及参数细节在用到时才发现已经记不起了，所以顺着这次系统调优，把常用的监控工具又都熟悉了一遍。好记性不如烂笔头儿，记下来留备后用。</p>
<p>需要说明的是，本文可能会很长，没耐性的以及有痔疮的同学慎入 :)</p>
<h1 id="1-_流量监控">1. 流量监控</h1><h2 id="1-1_Ifstat">1.1 Ifstat</h2><p>比较简易的网络监控工具，可以监控网卡的实时流量。当你只关心整机的流量而并不关心具体服务时，这个工具很趁手。</p>
<h3 id="1-1-1_安装">1.1.1 安装</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://pkgs.repoforge.org/ifstat/ifstat-1.1-1.2.el6.rf.x86_64.rpm&#10;rpm -ivh ifstat-1.1-1.2.el6.rf.x86_64.rpm</span><br></pre></td></tr></table></figure>
<h3 id="1-1-2_使用">1.1.2 使用</h3><p>老规矩，看下man<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS</span><br><span class="line">    ifstat accepts <span class="operator">the</span> following options:</span><br><span class="line"></span><br><span class="line">    -l  Enables monitoring <span class="operator">of</span> loopback interfaces <span class="keyword">for</span> which statistics are available. By default, ifstat monitors all non-loopback interfaces that are up.</span><br><span class="line">    <span class="comment"># ifstat 默认不监控环回网络接口， -l 之后可以看到环回网络接口的流量</span></span><br><span class="line">    -<span class="operator">a</span>  Enables monitoring <span class="operator">of</span> all interfaces found <span class="keyword">for</span> which statistics are available.</span><br><span class="line">    <span class="comment"># 监控所有网络接口</span></span><br><span class="line">    -z  Hides interface which counters are <span class="constant">null</span>, eg interfaces that are up but <span class="operator">not</span> used.</span><br><span class="line">    <span class="comment"># 隐藏统计数为空的网络接口</span></span><br><span class="line">    -i  Specifies <span class="operator">the</span> list <span class="operator">of</span> interfaces <span class="built_in">to</span> monitor, separated <span class="keyword">by</span> commas (<span class="keyword">if</span> <span class="operator">an</span> interface name has <span class="operator">a</span> <span class="constant">comma</span>, <span class="keyword">it</span> can be escaped <span class="operator">with</span> ’\’). Multiple instances <span class="operator">of</span> <span class="operator">the</span> options are added together.</span><br><span class="line">    <span class="comment"># -i 指定被监控的网络接口列表，逗号分割</span></span><br><span class="line">    -s  Equivalent <span class="built_in">to</span> -d snmp:[comm@][<span class="comment">#]host[/nn]] to poll a remote host through SNMP. See below for details.</span></span><br><span class="line">    <span class="comment"># 可以基于snmp协议，监控远端服务器</span></span><br><span class="line">    -h  Displays <span class="operator">a</span> <span class="keyword">short</span> help message.</span><br><span class="line">    -n  Turns off displaying <span class="operator">the</span> header periodically.</span><br><span class="line">    <span class="comment"># 关闭显示头信息(第一屏还是会有，超过一屏时就不会再有了)</span></span><br><span class="line">    -t  Adds <span class="operator">a</span> timestamp <span class="keyword">at</span> <span class="operator">the</span> beginning <span class="operator">of</span> <span class="keyword">each</span> <span class="built_in">line</span>.</span><br><span class="line">    <span class="comment"># 每行前添加时间戳</span></span><br><span class="line">    -T  Reports total bandwith <span class="keyword">for</span> all monitored interfaces.</span><br><span class="line">    <span class="comment"># 每行行尾添加一列，统计总流量</span></span><br><span class="line">    -A  Disables use <span class="operator">of</span> interface indexes: <span class="keyword">by</span> default, when polling mechanism is index based (snmp, ifmib), ifstat remembers indexes <span class="operator">of</span> monitored inter-faces <span class="built_in">to</span> poll only them. However, <span class="keyword">if</span> interfaces indexes change often (<span class="built_in">new</span> interfaces added, etc), you might loose some stats, hence this flag.Note that <span class="keyword">if</span> you ask ifstat <span class="built_in">to</span> monitor <span class="operator">a</span> non existent interface, <span class="keyword">it</span> will poll all interfaces <span class="keyword">until</span> <span class="keyword">it</span> finds <span class="operator">the</span> requested <span class="constant">one</span> (regardless <span class="operator">of</span> this flag) so you can poll <span class="keyword">for</span> <span class="operator">an</span> interface that goes up <span class="operator">and</span> down.</span><br><span class="line">    <span class="comment"># 关闭使用网络接口的索引。默认的网络接口轮寻机制是基于索引的，ifstat会从索引中找当前的网络接口而不会每次都使用系统调用。所以如果一台服务器的网络接口经常变更(譬如新增，等) 你可能会丢失一些信息。因此有了这个参数</span></span><br><span class="line">    -w  Uses fixed width columns, instead <span class="operator">of</span> enlarging them <span class="keyword">if</span> needed <span class="keyword">for</span> interfaces names <span class="built_in">to</span> fit.</span><br><span class="line">    <span class="comment"># 用固定的列宽代替自适应的列款</span></span><br><span class="line">    -W  Wrap <span class="keyword">lines</span> that are larger than <span class="operator">the</span> terminal width (implies -w). Wrapped <span class="keyword">lines</span> are prefixed <span class="operator">with</span> <span class="operator">a</span> cycling letter <span class="built_in">to</span> ease reading.</span><br><span class="line">    <span class="comment"># 如果每行的宽度超过屏幕宽度，自动换行。</span></span><br><span class="line">    -S  Keep stats updated <span class="command"><span class="keyword">on</span> <span class="title">the</span> <span class="title">same</span> <span class="title">line</span> <span class="title">if</span> <span class="title">possible</span> (<span class="title">no</span> <span class="title">scrolling</span> <span class="title">nor</span> <span class="title">wrapping</span>).</span></span><br><span class="line">    <span class="comment"># 输出结果不再是追加。而是更新同一行。</span></span><br><span class="line">    -b  Reports bandwith <span class="operator">in</span> kbits/<span class="built_in">sec</span> instead <span class="operator">of</span> kbytes/<span class="built_in">sec</span>.</span><br><span class="line">    <span class="comment"># kbit 代替 kbyte</span></span><br><span class="line">    -q  Quiet mode, warnings are <span class="operator">not</span> printed.</span><br><span class="line">    -v  Displays <span class="built_in">version</span> <span class="operator">and</span> <span class="operator">the</span> compiled-<span class="operator">in</span> drivers.</span><br><span class="line">       </span><br><span class="line">    delay</span><br><span class="line">        delay is <span class="operator">the</span> delay between updates <span class="operator">in</span> <span class="built_in">seconds</span>, which defaults <span class="built_in">to</span> <span class="number">1.</span>  A decimal <span class="built_in">number</span> can be specified <span class="keyword">for</span> intervals shorter than <span class="operator">a</span> <span class="keyword">second</span>. (<span class="built_in">min</span>-imum <span class="number">0.1</span>)</span><br><span class="line">A <span class="keyword">second</span> delay can also be specified (separated <span class="built_in">from</span> <span class="operator">the</span> <span class="keyword">first</span> <span class="constant">one</span> <span class="keyword">by</span> <span class="operator">a</span> ’/’). In that <span class="keyword">case</span> <span class="operator">the</span> <span class="keyword">first</span> delay will be used <span class="keyword">for</span> <span class="operator">the</span> <span class="keyword">first</span> poll <span class="keyword">after</span> <span class="built_in">start</span> <span class="operator">and</span> <span class="operator">the</span> <span class="keyword">second</span> <span class="constant">one</span> will be used <span class="keyword">for</span> all following polls (This can be used <span class="built_in">to</span> have <span class="operator">a</span> <span class="string">"fast"</span> <span class="built_in">start</span> when running <span class="keyword">for</span> <span class="operator">a</span> <span class="keyword">long</span> <span class="keyword">while</span> <span class="operator">with</span> <span class="operator">a</span> big delay).</span><br><span class="line">        <span class="comment"># 每次显示刷新的时间间隔。默认是1.也接受一个浮点数，最小为0.1. 接受一个第二间隔的参数，通过'/' 分割，如 0.1／3. 这种情况下，第一次显示使用0.1，后面显示的时间间隔使用3. (这种方式可以用来"快速"启动，然后缓慢轮寻)</span></span><br><span class="line">    count</span><br><span class="line">        count is <span class="operator">the</span> <span class="built_in">number</span> <span class="operator">of</span> updates <span class="keyword">before</span> stopping. If <span class="operator">not</span> specified, <span class="keyword">it</span> is unlimited.</span><br><span class="line">        <span class="comment"># 指定刷新的次数。如果不指定，默认无限。</span></span><br></pre></td></tr></table></figure></p>
<p>通常用法：<code>ifstat -a -t -T 0.1/2</code></p>
<h2 id="1-2_Iftop">1.2 Iftop</h2><p>和ifstat 相比，iftop提供更丰富的监控维度。可以细化到网卡甚至端口服务。当网络成为瓶颈时，这个工具可以很快帮你找出是哪个服务占用了你网卡以及流量。</p>
<h3 id="1-2-1_安装">1.2.1 安装</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//pkgs.repoforge.org/iftop/iftop-0.17-1.el6.rf.x86_64.rpm</span></span><br><span class="line">rpm -ivh iftop-<span class="number">0.17</span>-<span class="number">1</span><span class="class">.el6</span><span class="class">.rf</span><span class="class">.x86_64</span><span class="class">.rpm</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-2_使用">1.2.2 使用</h3><p>老规矩， 看下man<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS</span><br><span class="line">    -h     Print <span class="operator">a</span> summary <span class="operator">of</span> usage.</span><br><span class="line">    -n     Don’t <span class="built_in">do</span> hostname lookups. <span class="comment">#不对ip做反向解析</span></span><br><span class="line">    -N     Do <span class="operator">not</span> <span class="built_in">resolve</span> port <span class="built_in">number</span> <span class="built_in">to</span> service names <span class="comment"># 不会把port解析成服务名</span></span><br><span class="line">    -p     Run <span class="operator">in</span> promiscuous mode, so that traffic which does <span class="operator">not</span> pass directly through <span class="operator">the</span> specified interface is also counted. <span class="comment"># 运行在混杂模式中，所以不是来自指定网络接口的流量也会被统计</span></span><br><span class="line">    -P     Turn <span class="command"><span class="keyword">on</span> <span class="title">port</span> <span class="title">display</span>. #显示端口号</span></span><br><span class="line">    -b     Don’t display bar graphs <span class="operator">of</span> traffic.</span><br><span class="line">    -B     Display bandwidth rates <span class="operator">in</span> <span class="keyword">bytes</span>/<span class="built_in">sec</span> rather than bits/<span class="built_in">sec</span>. <span class="comment">#显示byte</span></span><br><span class="line">    -i interface</span><br><span class="line">        Listen <span class="built_in">to</span> packets <span class="command"><span class="keyword">on</span> <span class="title">interface</span>. #指定网络接口</span></span><br><span class="line">    -f <span class="built_in">filter</span> code</span><br><span class="line">        Use  <span class="built_in">filter</span> code <span class="built_in">to</span> select <span class="operator">the</span> packets <span class="built_in">to</span> count. Only IP packets are ever counted, so <span class="operator">the</span> specified code is evaluated <span class="keyword">as</span> (<span class="built_in">filter</span> code) <span class="operator">and</span> ip.</span><br><span class="line">    -F net/mask</span><br><span class="line">        Specifies <span class="operator">a</span> network <span class="keyword">for</span> traffic analysis.  If specified, iftop will only <span class="built_in">include</span> packets flowing <span class="operator">in</span> <span class="built_in">to</span> <span class="operator">or</span> out <span class="operator">of</span> <span class="operator">the</span> given network, <span class="operator">and</span> packet direction  is  determined  <span class="built_in">relative</span>  <span class="built_in">to</span>  <span class="operator">the</span>  network  boundary, rather than <span class="built_in">to</span> <span class="operator">the</span> interface.  You may specify mask <span class="keyword">as</span> <span class="operator">a</span> dotted quad, such <span class="keyword">as</span> /<span class="number">255.255</span>.255.0, <span class="operator">or</span> <span class="keyword">as</span> <span class="operator">a</span> single <span class="built_in">number</span> specifying <span class="operator">the</span> <span class="built_in">number</span> <span class="operator">of</span> bits <span class="built_in">set</span> <span class="operator">in</span> <span class="operator">the</span> netmask, such <span class="keyword">as</span> /<span class="number">24.</span> <span class="comment"># 指定ip区段以及掩码</span></span><br><span class="line">    -c config <span class="built_in">file</span></span><br><span class="line">        Specifies <span class="operator">an</span> alternate config <span class="built_in">file</span>.  If <span class="operator">not</span> specified, iftop will use ~/.iftoprc <span class="keyword">if</span> <span class="keyword">it</span> exists.  See below <span class="keyword">for</span> <span class="operator">a</span> description <span class="operator">of</span> config <span class="built_in">files</span> <span class="comment">#可以指定配置文件，文件格式详见 man</span></span><br></pre></td></tr></table></figure></p>
<p>通常用法：<code>iftop -N -n -B -i em1</code></p>
<h3 id="1-2-3_显示">1.2.3 显示</h3><p><img src="http://user-image.logdown.io/user/1417/blog/1391/post/199171/GwYk2VoQ4eG6knaEFwb0_iftop.png" alt="iftop.png"></p>
<ol>
<li>第一行：当前带宽</li>
<li>中间区域： 左-本机ip 中-远端ip 右-2／10／40 秒的实时流量</li>
<li>底部：<br> TX：发送<br> RX：接收<br> Total：总流量<br> comm: 从iftop启动到现在产生的流量<br> peak：当前流量峰值／s<br> 右侧三列： 2／10／40 秒的平均值</li>
</ol>
<h3 id="1-2-4_交互操作">1.2.4 交互操作</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Host <span class="keyword">display</span>:                          </span><br><span class="line"> <span class="keyword">n</span> - toggle DNS host resolution   #切换dns反向解析     </span><br><span class="line"> s - toggle show source host # 切换显示源主机           </span><br><span class="line"> <span class="keyword">d</span> - toggle show destination host # 切换显示目的主机     </span><br><span class="line"> t - cycle <span class="keyword">line</span> <span class="keyword">display</span> mode # 循环切换不同的展示模式 单行／多行           </span><br><span class="line"></span><br><span class="line">Port <span class="keyword">display</span>:                          </span><br><span class="line"> <span class="keyword">N</span> - toggle service resolution  #切换端口到服务解析        </span><br><span class="line"> S - toggle show source port    #切换展示源端口       </span><br><span class="line"> <span class="keyword">D</span> - toggle show destination port  #切换展示目的端口    </span><br><span class="line"> p - toggle port <span class="keyword">display</span>    #是否展示端口           </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Sorting:</span><br><span class="line"> 1/2/3 - <span class="keyword">sort</span> <span class="keyword">by</span> 1st/2nd/3rd column #1/2/3列排序</span><br><span class="line"> &lt; - <span class="keyword">sort</span> <span class="keyword">by</span> source name #源主机排序</span><br><span class="line"> &gt; - <span class="keyword">sort</span> <span class="keyword">by</span> dest name #目的主机排序</span><br><span class="line"> o - freeze current <span class="keyword">order</span> </span><br><span class="line"></span><br><span class="line">General:</span><br><span class="line"> P - <span class="keyword">pause</span> <span class="keyword">display</span>        </span><br><span class="line"> <span class="keyword">h</span> - toggle this <span class="keyword">help</span> <span class="keyword">display</span></span><br><span class="line"> b - toggle bar <span class="keyword">graph</span> <span class="keyword">display</span></span><br><span class="line"> B - cycle bar <span class="keyword">graph</span> average</span><br><span class="line">                                   </span><br><span class="line"> j/k - scroll <span class="keyword">display</span></span><br><span class="line"> f - <span class="keyword">edit</span> filter code</span><br><span class="line"> <span class="keyword">l</span> - <span class="keyword">set</span> screen filter</span><br><span class="line"> <span class="keyword">L</span> - lin/<span class="keyword">log</span> scales</span><br><span class="line"> ! - <span class="keyword">shell</span> command</span><br><span class="line"> q - quit</span><br><span class="line"> T - toggle cummulative <span class="keyword">line</span> totals</span><br></pre></td></tr></table></figure>
<h2 id="1-3_Iptraf">1.3 Iptraf</h2><pre><code>和iptop的功能比较类似，实时性更好一些，UI也更易懂。
</code></pre><h3 id="1-3-1_安装">1.3.1 安装</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> iptraf</span><br></pre></td></tr></table></figure>
<p>这东西纯界面的，menu也很清晰，就不多说了～</p>
<p><img src="http://user-image.logdown.io/user/1417/blog/1391/post/199171/mlS8w6p8Rt27r7lTk9Xc_traffic.png" alt="traffic.png"></p>
<h1 id="2-_CPU">2. CPU</h1><h2 id="2-1_vmstat">2.1 vmstat</h2><p>vmstat可以说是最常用的cpu监控工具了，不但可以监控cpu的使用情况，还以cpu为维度，列出了请求队列，内存，io，中断等信息，方便我们从多个维度观察cpu信息，及时找出瓶颈。</p>
<h3 id="使用">使用</h3><p><code>vmstat -t -S m 2</code> #每秒刷新，附带时间戳; 涉及到容量的单位为M(-S 的可选参数为  k/K/m/M 对应 1000/1024/1000000/1048576 bytes )</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">procs</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">memory</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">swap</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">io</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">system</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">cpu</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">timestamp</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"> <span class="comment">r</span>  <span class="comment">b</span>   <span class="comment">swpd</span>   <span class="comment">free</span>   <span class="comment">buff</span>  <span class="comment">cache</span>   <span class="comment">si</span>   <span class="comment">so</span>    <span class="comment">bi</span>    <span class="comment">bo</span>   <span class="comment">in</span>   <span class="comment">cs</span> <span class="comment">us</span> <span class="comment">sy</span> <span class="comment">id</span> <span class="comment">wa</span> <span class="comment">st</span></span><br><span class="line"> <span class="comment">5</span>  <span class="comment">0</span>      <span class="comment">0</span>    <span class="comment">228</span>   <span class="comment">2137</span>  <span class="comment">18902</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">1</span>    <span class="comment">13</span>    <span class="comment">0</span>    <span class="comment">0</span>  <span class="comment">1</span>  <span class="comment">1</span> <span class="comment">98</span>  <span class="comment">0</span>  <span class="comment">0	2014</span><span class="literal">-</span><span class="comment">05</span><span class="literal">-</span><span class="comment">15</span> <span class="comment">17:53:06</span> <span class="comment">CST</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>列</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>procs-r</td>
<td>执行队列中的进程数(等待被执行的进程数)</td>
</tr>
<tr>
<td>procs-b</td>
<td>等待I/O的进程数</td>
</tr>
<tr>
<td>memory-swpd</td>
<td>使用交换内存的大小</td>
</tr>
<tr>
<td>memory-free</td>
<td>空闲内存的大小</td>
</tr>
<tr>
<td>memory-buff</td>
<td>buffer使用的内存大小，一般对块设备读写会用到buff</td>
</tr>
<tr>
<td>memory-cache</td>
<td>cache使用的内存大小，一般对文件读写会用到cache</td>
</tr>
<tr>
<td>swap-si</td>
<td>由内存写入到交换区的大小</td>
</tr>
<tr>
<td>swap-so</td>
<td>由交换区写入到内存的大小</td>
</tr>
<tr>
<td>io-bi</td>
<td>写入块设备的块数。(单位是block)</td>
</tr>
<tr>
<td>io-bo</td>
<td>从块设备接收到的块数。(单位是block)</td>
</tr>
<tr>
<td>system-in</td>
<td>系统中断数，包括时钟中断</td>
</tr>
<tr>
<td>system-cs</td>
<td>系统的上下文切换数</td>
</tr>
<tr>
<td>cpu-us</td>
<td>用户进程使用CPU的百分比</td>
</tr>
<tr>
<td>cpu-sy</td>
<td>系统进程使用CPU的百分比</td>
</tr>
<tr>
<td>cpu-id</td>
<td>空闲PU的百分比</td>
</tr>
<tr>
<td>cpu-wa</td>
<td>等待I/O的CPU百分比</td>
</tr>
<tr>
<td>cpu-st</td>
<td>被虚拟机偷取的CPU百分比</td>
</tr>
</tbody>
</table>
<h2 id="2-2_mpstat">2.2 mpstat</h2><p>虽然 vmstat 已经很强大了，但随着多核cpu的出现，vmstat有时有些捉襟见肘。笔者之前遇到一个案例，在系统压力很大时，mysql slave服务器出现了较大的延迟，从vmstat看，io／cpu都不高。binlog同步没有延迟，但是在binlog重放时显然拖慢了整体进度。最后通过mpstat观察发现，只有一个核的使用率很高，而vmstat显示的平均值，所以整体很低。这就说明mysql的主从机制中，从服务器重放sql是单线程的，无法利用多核，难怪在系统繁忙时，数据会有延迟。好了，不吐槽了，我们接茬儿说回mpstat</p>
<h3 id="使用-1">使用</h3><p><code>mpstat -u -P [ALL|0,1,2...]</code><br>|# -P 代表查看CPU的情况 ALL会列出全部CPU,也可以指定核编号，”,”分割<br><code>mpstat -I [SUM|CPU|ALL]</code>(不太常用，因为-P的结果中也会有中断数)<br>|# -I 代表查看CPU中断  SUM为所有cpu汇总,CPU代表列出所有核的中断，ALL为前两者之和</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Linux <span class="number">2.6</span>.32-<span class="number">431.</span>el6.x86_64 (beta-<span class="number">01.</span>cloud) 	<span class="number">05</span>/<span class="number">15</span>/<span class="number">2014</span> 	_x86_64_	(<span class="number">24</span> CPU)</span><br><span class="line"></span><br><span class="line"><span class="number">08</span>:<span class="number">56</span>:<span class="number">32</span> PM  CPU    <span class="variable">%usr</span>   <span class="variable">%nice</span>    <span class="variable">%sys</span> <span class="variable">%iowait</span>    <span class="variable">%irq</span>   <span class="variable">%soft</span>  <span class="variable">%steal</span>  <span class="variable">%guest</span>   <span class="variable">%idle</span></span><br><span class="line"><span class="number">08</span>:<span class="number">56</span>:<span class="number">34</span> PM  all   <span class="number">10.17</span>    <span class="number">0.00</span>   <span class="number">11.28</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">78.54</span></span><br><span class="line"><span class="number">08</span>:<span class="number">56</span>:<span class="number">34</span> PM    <span class="number">0</span>    <span class="number">0.50</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">99.50</span></span><br><span class="line"><span class="number">08</span>:<span class="number">56</span>:<span class="number">34</span> PM    <span class="number">1</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">3.50</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">96.50</span></span><br><span class="line"><span class="number">08</span>:<span class="number">56</span>:<span class="number">34</span> PM    <span class="number">2</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">08</span>:<span class="number">56</span>:<span class="number">34</span> PM    <span class="number">3</span>   <span class="number">30.43</span>    <span class="number">0.00</span>   <span class="number">34.78</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">34.78</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>列</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>irq</td>
<td>硬中断的CPU百分比</td>
</tr>
<tr>
<td>soft</td>
<td>软中断的CPU百分比(其他的项参考vmstat章节)</td>
</tr>
</tbody>
</table>
<h1 id="3-_I／O">3. I／O</h1><h2 id="3-1_iostat">3.1 iostat</h2><h3 id="使用-2">使用</h3><p><code>iostat -x -t [-k/-m] 3</code><br> |# -x 会展示一些扩展数据<br> |# -t 会展示刷新时间<br> |# -k 以kbytes为单位做展示<br> |# -m 以mbytes为单位做展示</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">05</span>/<span class="number">15</span>/<span class="number">2014</span> <span class="number">06</span>:<span class="number">25</span>:<span class="number">35</span> PM</span><br><span class="line">avg-cpu:  <span class="variable">%user</span>   <span class="variable">%nice</span> <span class="variable">%system</span> <span class="variable">%iowait</span>  <span class="variable">%steal</span>   <span class="variable">%idle</span></span><br><span class="line">          <span class="number">10.38</span>    <span class="number">0.00</span>   <span class="number">10.89</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">78.73</span></span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  <span class="variable">%util</span></span><br><span class="line">sda               <span class="number">0.00</span>  <span class="number">1017.00</span>    <span class="number">0.00</span>   <span class="number">23.00</span>     <span class="number">0.00</span>  <span class="number">8320.00</span>   <span class="number">361.74</span>     <span class="number">0.01</span>    <span class="number">0.22</span>   <span class="number">0.07</span>   <span class="number">0.15</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>列</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>nice</td>
<td>用做nice加权的进程分配的用户态cpu时间比(CPU的其它项，见vmstat章节)</td>
</tr>
<tr>
<td>rrqm/s</td>
<td>队列中每秒合并的读请求数</td>
</tr>
<tr>
<td>wrqm/s</td>
<td>队列中每秒合并的写请求数</td>
</tr>
<tr>
<td>r/s</td>
<td>每秒完成的读请求数</td>
</tr>
<tr>
<td>w/s</td>
<td>每秒完成的写请求数</td>
</tr>
<tr>
<td>rsec/s</td>
<td>每秒读取的扇区数</td>
</tr>
<tr>
<td>wsec/s</td>
<td>每秒写入的扇区数</td>
</tr>
<tr>
<td>avgrq-sz</td>
<td>平均每次io操作的扇区大小(单位为扇区)</td>
</tr>
<tr>
<td>avgqu-sz</td>
<td>I／O队列的平均长度</td>
</tr>
<tr>
<td>await</td>
<td>每次I/O请求的处理时间。这个时间包括排队时间+处理时间 (ms)</td>
</tr>
<tr>
<td>svctm</td>
<td>每次I/O请求的处理时间。这个时间不包括排队时间 (ms)</td>
</tr>
<tr>
<td>%util</td>
<td>I/O请求所占用的CPU时间百分比(<strong>这一项是衡量i/o负载的重要指标</strong>)</td>
</tr>
</tbody>
</table>
<h2 id="3-2_iotop">3.2 iotop</h2><p>iostat 是从宏观上监控系统i/o的整体情况，于是它就存在个弱点，当我们发现系统i/o过高甚至成为瓶颈时，无法查看到底是哪个进程导致的io过高。这个时候就iotop出场了。<br>关于iotop的介绍，详见前几日的博文 <a href="http://harrycode.logdown.com/posts/198725-introduction-to-iotop" target="_blank" rel="external">IOTop 简介</a></p>
<h1 id="4-_综合">4. 综合</h1><p>这个世界有小而精的东西，也永远都不缺大而全的东西</p>
<h2 id="4-1_htop">4.1 htop</h2><p>htop是top的增强版，功能更强大，性能更好。详细的介绍参见之前的一篇博客 <a href="http://harrycode.logdown.com/posts/198662-change-replacing-the-top-process-management-tools-under-linux-htop" target="_blank" rel="external">[转]Linux下取代top的进程管理工具 htop</a></p>
<h2 id="4-2_sar">4.2 sar</h2><p>sar可以快速收集服务器上的各项信息并显示，包括CPU，内存，I/O，中断，IP，TCP，UDP等。<br>这个工具通常都被预装在了服务器上，如果真的那么悲催居然没有，可以去找这个工具集 [sysstat][1] </p>
<h2 id="用法">用法</h2><p><code>sar [ 选项 ] [ &lt;时间间隔&gt; [ &lt;次数&gt; ] ]</code></p>
<p><strong>不带任何选项的sar，默认展示cpu信息</strong><br>展示的各项与mpstat一致，相关描述可参考mpstat -P的章节</p>
<p><code>sar 2</code></p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Linux <span class="number">2.6</span>.32-<span class="number">431.</span>el6.x86_64 (beta-<span class="number">01.</span>cloud) 	<span class="number">05</span>/<span class="number">15</span>/<span class="number">2014</span> 	_x86_64_	(<span class="number">24</span> CPU)</span><br><span class="line"></span><br><span class="line"><span class="number">09</span>:<span class="number">24</span>:<span class="number">03</span> PM     CPU     <span class="variable">%user</span>     <span class="variable">%nice</span>   <span class="variable">%system</span>   <span class="variable">%iowait</span>    <span class="variable">%steal</span>     <span class="variable">%idle</span></span><br><span class="line"><span class="number">09</span>:<span class="number">24</span>:<span class="number">05</span> PM     all     <span class="number">10.09</span>      <span class="number">0.00</span>     <span class="number">11.20</span>      <span class="number">0.00</span>      <span class="number">0.00</span>     <span class="number">78.71</span></span><br><span class="line"><span class="number">09</span>:<span class="number">24</span>:<span class="number">07</span> PM     all     <span class="number">10.33</span>      <span class="number">0.00</span>     <span class="number">11.05</span>      <span class="number">0.00</span>      <span class="number">0.00</span>     <span class="number">78.62</span></span><br></pre></td></tr></table></figure>
<p><strong>-b    I/O 和传输速率信息状况</strong></p>
<p><code>sar -b 2</code></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Linux <span class="number">2.6</span>.<span class="number">32</span>-<span class="number">431</span><span class="class">.el6</span><span class="class">.x86_64</span> (beta-<span class="number">01</span>.cloud) 	<span class="number">05</span>/<span class="number">15</span>/<span class="number">2014</span> 	_x86_64_	(<span class="number">24</span> CPU)</span><br><span class="line"></span><br><span class="line"><span class="number">04</span>:<span class="number">17</span>:<span class="number">26</span> PM       tps      rtps      wtps   bread/s   bwrtn/s</span><br><span class="line"><span class="number">04</span>:<span class="number">17</span>:<span class="number">29</span> PM    <span class="number">481.00</span>      <span class="number">0.00</span>    <span class="number">481.00</span>      <span class="number">0.00</span>   <span class="number">4856.00</span></span><br><span class="line"><span class="number">04</span>:<span class="number">17</span>:<span class="number">32</span> PM      <span class="number">4.67</span>      <span class="number">0.00</span>      <span class="number">4.67</span>      <span class="number">0.00</span>    <span class="number">752.00</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>列</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>tps</td>
<td>每秒对物理磁盘的I/O请求数</td>
</tr>
<tr>
<td>rtps</td>
<td>每秒对物理磁盘的I/O读请求数</td>
</tr>
<tr>
<td>wtps</td>
<td>每秒对物理磁盘的I/O写请求数</td>
</tr>
<tr>
<td>bread/s</td>
<td>每秒从物理磁盘读取的数据块(block)数目。2.4及以上，一个block为512bytes</td>
</tr>
<tr>
<td>bwrtn/s</td>
<td>每秒对物理磁盘写的数据块数目</td>
</tr>
</tbody>
</table>
<p><strong>-d  块设备的使用情况</strong></p>
<p><code>sar -p -d 2</code></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sarLinux <span class="number">2.6</span>.<span class="number">32</span>-<span class="number">431</span>.el6.x86_64 (beta-<span class="number">01</span>.cloud) 	<span class="number">05</span><span class="regexp">/15/</span><span class="number">2014</span> 	_x86_64_	(<span class="number">24</span> CPU)</span><br><span class="line"></span><br><span class="line"><span class="number">05</span>:<span class="number">11</span>:<span class="number">06</span> PM       DEV       tps  rd_sec<span class="regexp">/s  wr_sec/</span>s  avgrq-sz  avgqu-sz     await     svctm     %util</span><br><span class="line"><span class="number">05</span>:<span class="number">11</span>:<span class="number">09</span> PM       sda      <span class="number">1.34</span>      <span class="number">0.00</span>     <span class="number">58.86</span>     <span class="number">44.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"></span><br><span class="line"><span class="number">05</span>:<span class="number">11</span>:<span class="number">09</span> PM       DEV       tps  rd_sec<span class="regexp">/s  wr_sec/</span>s  avgrq-sz  avgqu-sz     await     svctm     %util</span><br><span class="line"><span class="number">05</span>:<span class="number">11</span>:<span class="number">12</span> PM       sda      <span class="number">1.99</span>      <span class="number">0.00</span>    <span class="number">685.71</span>    <span class="number">344.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>列</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEV</td>
<td>被监控的块设备名称</td>
</tr>
<tr>
<td>tps</td>
<td>每秒传输给块设备的请求数(I/O请求数)。多个逻辑请求会被合并成一个物理请求</td>
</tr>
<tr>
<td>rd_sec/s</td>
<td>每秒读取的扇区数(sector)。一个扇区512bytes</td>
</tr>
<tr>
<td>wr_sec/s</td>
<td>每秒写入的扇区数(sector)。一个扇区512bytes</td>
</tr>
<tr>
<td>avgrq-sz</td>
<td>平均每次I/O请求的扇区数</td>
</tr>
<tr>
<td>avgqu-sz</td>
<td>I/O请求队列的平均长度</td>
</tr>
<tr>
<td>await</td>
<td>每次I/O请求的处理时间。这个时间包括排队时间+处理时间 (ms)</td>
</tr>
<tr>
<td>svctm</td>
<td>每次I/O请求的处理时间。这个时间不包括排队时间 (ms)</td>
</tr>
<tr>
<td>%util</td>
<td>I/O请求所占用的CPU时间百分比(<strong>这一项是衡量i/o负载的重要指标</strong>)</td>
</tr>
</tbody>
</table>
<p><strong>-P cpu的使用情况，支持多核， 与mpstat 一致</strong></p>
<p><code>sar -P [ALL|0,1,2...] 2</code></p>
<p><strong>-q   队列以及负载的情况</strong></p>
<p><code>sar -q 2</code></p>
<table>
<thead>
<tr>
<th>列</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>runq-sz</td>
<td>准备进入执行队列的进程数</td>
</tr>
<tr>
<td>plist-sz</td>
<td>进程列表中的进程数</td>
</tr>
<tr>
<td>ldavg-1</td>
<td>最近一分钟的系统负载</td>
</tr>
<tr>
<td>ldavg-5</td>
<td>最近5分钟的系统负载</td>
</tr>
<tr>
<td>ldavg-15</td>
<td>最近15分钟的系统负载</td>
</tr>
</tbody>
</table>
<p><strong>-n  网络相关的情况</strong></p>
<p>根据关键字来基于不同维度展示网络相关的情况，关键字包括 DEV, EDEV, NFS, NFSD, SOCK, IP, EIP, ICMP, EICMP, TCP, ETCP, UDP, SOCK6, IP6, EIP6, ICMP6, EICMP6 and UDP6， 较为常用的是 DEV和SOCK</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DEV</strong></td>
<td>所有网络设备的活动统计</td>
</tr>
<tr>
<td>IFACE</td>
<td>网络接口名</td>
</tr>
<tr>
<td>rxpck/s</td>
<td>每秒收到的package</td>
</tr>
<tr>
<td>txpck/s</td>
<td>每秒发送的package</td>
</tr>
<tr>
<td>rxkB/s</td>
<td>每秒收到的字节数</td>
</tr>
<tr>
<td>txkB/s</td>
<td>每秒发送的字节数</td>
</tr>
<tr>
<td>rxcmp/s</td>
<td>每秒收到的压缩包数</td>
</tr>
<tr>
<td>txcmp/s</td>
<td>每秒发送的压缩包数</td>
</tr>
<tr>
<td>rxmcst/s</td>
<td>每秒收到的多播包数</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>SOCK</strong></td>
<td>所有网络套接字的活动统计</td>
</tr>
<tr>
<td>totsck</td>
<td>使用的套接字总数</td>
</tr>
<tr>
<td>tcpsck</td>
<td>使用的Tcp套接字总数</td>
</tr>
<tr>
<td>udpsck</td>
<td>使用的Udp套接字总数</td>
</tr>
<tr>
<td>rawsck</td>
<td>使用的Raw套接字总数</td>
</tr>
<tr>
<td>ip-frag</td>
<td>使用的ip段总数</td>
</tr>
<tr>
<td>tcp-tw</td>
<td>当前Time_Wait的套接字总数</td>
</tr>
</tbody>
</table>
<p>就这么多吧，敲的手抖，把最近用到的工具简单罗列了下下，希望对大家有用。<br>需要注意一下，上面的演示都是基于CentOSd的，其他操作系统中，同样的工具输出结果会略有不同，要想了解细节还是要靠 man.</p>
<p>Enjoy~</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.harrycode.com/2014/05/15/linux-server-system-monitor-tool-collecting/" data-id="cibq3ipoh000mgh6ahnbcjcqg" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tools/">Tools</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-introduction-to-iotop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/13/introduction-to-iotop/" class="article-date">
  <time datetime="2014-05-13T05:19:00.000Z" itemprop="datePublished">2014-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/13/introduction-to-iotop/">IOTop 简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介">简介</h2><p>IOTop 是一款Python程序，使用Top的UI样式， 可以查看基于进程／线程／User等多种维度来查看／监控服务器当前的I/O情况</p>
<h2 id="安装">安装</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//guichaz.free.fr/iotop/files/iotop-0.6-1.noarch.rpm</span></span><br><span class="line">sudo rpm -ivh iotop-<span class="number">0.6</span>-<span class="number">1</span><span class="class">.noarch</span><span class="class">.rpm</span></span><br></pre></td></tr></table></figure>
<h2 id="使用">使用</h2><p>简单翻译下 —help ，用法很简单</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">beta-<span class="number">01</span><span class="comment"># iotop --help</span></span><br><span class="line">Usage: /usr/sbin/iotop [OPTIONS]</span><br><span class="line"></span><br><span class="line">DISK READ <span class="operator">and</span> DISK WRITE are <span class="operator">the</span> block I/O bandwidth used during <span class="operator">the</span> sampling</span><br><span class="line">period. SWAPIN <span class="operator">and</span> IO are <span class="operator">the</span> percentages <span class="operator">of</span> <span class="built_in">time</span> <span class="operator">the</span> thread spent respectively</span><br><span class="line"><span class="keyword">while</span> swapping <span class="operator">in</span> <span class="operator">and</span> waiting <span class="command"><span class="keyword">on</span> <span class="title">I</span>/<span class="title">O</span> <span class="title">more</span> <span class="title">generally</span>. <span class="title">PRIO</span> <span class="title">is</span> <span class="title">the</span> <span class="title">I</span>/<span class="title">O</span> <span class="title">priority</span> <span class="title">at</span></span></span><br><span class="line">which <span class="operator">the</span> thread is running (<span class="built_in">set</span> <span class="keyword">using</span> <span class="operator">the</span> ionice <span class="command"><span class="keyword">command</span>).</span></span><br></pre></td></tr></table></figure>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -<span class="ruby">-version             show program<span class="string">'s version number and exit</span><br><span class="line"></span></span>  -<span class="ruby">h, --help            show this help message <span class="keyword">and</span> exit</span><br><span class="line"></span>  -<span class="ruby">o, --only            only show processes <span class="keyword">or</span> threads actually doing <span class="constant">I</span>/<span class="constant">O</span> <span class="comment">#只显示当前有IO操作的进程或线程</span></span><br><span class="line"></span>  -<span class="ruby">b, --batch           non-interactive mode <span class="comment"># 运行在非交互模式下</span></span><br><span class="line"></span>  -<span class="ruby">n <span class="constant">NUM</span>, --iter=<span class="constant">NUM</span>    number of iterations before ending [infinite] <span class="comment"># 非交互模式下展示的次数</span></span><br><span class="line"></span>  -<span class="ruby">d <span class="constant">SEC</span>, --delay=<span class="constant">SEC</span>   delay between iterations [<span class="number">1</span> second] <span class="comment">#刷新的时间间隔</span></span><br><span class="line"></span>  -<span class="ruby">p <span class="constant">PID</span>, --pid=<span class="constant">PID</span>     processes/threads to monitor [all] <span class="comment">#只显示指定进程／线程的IO信息</span></span><br><span class="line"></span>  -<span class="ruby">u <span class="constant">USER</span>, --user=<span class="constant">USER</span>  users to monitor [all] <span class="comment">#只显示指定用户的进程所发生的IO</span></span><br><span class="line"></span>  -<span class="ruby"><span class="constant">P</span>, --processes       only show processes, <span class="keyword">not</span> all threads <span class="comment"># 只显示进程而不是所有的线程</span></span><br><span class="line"></span>  -<span class="ruby">a, --accumulated     show accumulated <span class="constant">I</span>/<span class="constant">O</span> instead of bandwidth <span class="comment">#在IOTOP启动后 显示每个进程／线程处理的IO总数</span></span><br><span class="line"></span>  -<span class="ruby">k, --kilobytes       use kilobytes instead of a human friendly unit <span class="comment"># 以KB为单位进行显示</span></span><br><span class="line"></span>  -<span class="ruby">t, --time            add a timestamp on each line (implies --batch) <span class="comment"># 显示时在每行添加当前时间</span></span><br><span class="line"></span>  -<span class="ruby">q, --quiet           suppress some lines of header (implies --batch)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Controls: left <span class="operator">and</span> <span class="constant">right</span> arrows <span class="built_in">to</span> change <span class="operator">the</span> sorting column, r <span class="built_in">to</span> invert <span class="operator">the</span></span><br><span class="line">sorting order, o <span class="built_in">to</span> toggle <span class="operator">the</span> <span class="comment">--only option, p to toggle the --processes</span></span><br><span class="line">option, <span class="operator">a</span> <span class="built_in">to</span> toggle <span class="operator">the</span> <span class="comment">--accumulated option, q to quit, any other key to force</span></span><br><span class="line"><span class="operator">a</span> refresh.</span><br><span class="line"></span><br><span class="line">控制：</span><br><span class="line"><span class="string">'左右键'</span>用来改变排序的列，</span><br><span class="line"><span class="string">'r'</span>用来切换正序/倒序, </span><br><span class="line"><span class="string">'o'</span> 用来切换 <span class="comment">--only模式, </span></span><br><span class="line"><span class="string">'p'</span> 用来切换 <span class="comment">--processes 模式， </span></span><br><span class="line"><span class="string">'a'</span> 用来切换 <span class="comment">--accumulated模式, </span></span><br><span class="line"><span class="string">'q'</span> 用来推出，‘其他键’ 用来强制刷新</span><br></pre></td></tr></table></figure>
<p>PS: 笔者很喜欢 iotop -o 的玩法，祝大家也玩的愉快。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.harrycode.com/2014/05/13/introduction-to-iotop/" data-id="cibq3ipok000qgh6an0h4ws0w" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tools/">Tools</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-change-replacing-the-top-process-management-tools-under-linux-htop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/12/change-replacing-the-top-process-management-tools-under-linux-htop/" class="article-date">
  <time datetime="2014-05-12T13:14:00.000Z" itemprop="datePublished">2014-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/12/change-replacing-the-top-process-management-tools-under-linux-htop/">[转]Linux下取代top的进程管理工具 htop</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文转自  <a href="http://www.cnblogs.com/mchina/archive/2013/03/15/2858041.html" target="_blank" rel="external">http://www.cnblogs.com/mchina/archive/2013/03/15/2858041.html</a></p>
<h1 id="htop_简介">htop 简介</h1><p>This is htop, an interactive process viewer for Linux. It is a text-mode application (for console or X terminals) and requires ncurses.</p>
<p><strong>Comparison between htop and top</strong></p>
<ul>
<li>In ‘htop’ you can scroll the list vertically and horizontally to see all processes and complete command lines.</li>
<li>In ‘top’ you are subject to a delay for each unassigned key you press (especially annoying when multi-key escape sequences are triggered by accident).</li>
<li>‘htop’ starts faster (‘top’ seems to collect data for a while before displaying anything).</li>
<li>In ‘htop’ you don’t need to type the process number to kill a process, in ‘top’ you do.</li>
<li>In ‘htop’ you don’t need to type the process number or the priority value to renice a process, in ‘top’ you do.</li>
<li>‘htop’ supports mouse operation, ‘top’ doesn’t</li>
<li>‘top’ is older, hence, more used and tested.</li>
</ul>
<p>htop 是Linux系统中的一个互动的进程查看器，一个文本模式的应用程序(在控制台或者X终端中)，需要ncurses。<br>与Linux传统的top相比，htop更加人性化。它可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。</p>
<p><strong>与top相比，htop有以下优点：</strong></p>
<ul>
<li>可以横向或纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。</li>
<li>在启动上，比top 更快。</li>
<li>杀进程时不需要输入进程号。</li>
<li>htop 支持鼠标操作。</li>
<li>top 已经很老了。</li>
</ul>
<p>htop 官网：<a href="http://htop.sourceforge.net/" target="_blank" rel="external">http://htop.sourceforge.net/</a></p>
<h1 id="htop_安装">htop 安装</h1><p><strong>a. 源码包安装</strong><br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># tar zxvf htop-1.0.2.tar.gz</span></span><br><span class="line"><span class="preprocessor"># cd htop-1.0.2</span></span><br><span class="line"><span class="preprocessor"># ./configure</span></span><br><span class="line"><span class="preprocessor"># make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure></p>
<p>若出现错误：<br>configure: error: You may want to use —disable-unicode or install libncursesw.<br>则需安装 ncurses-devel<br><code>yum install ncurses-devel</code></p>
<p><strong>b. RHEL/CentOS 安装</strong></p>
<p>可以通过 yum install htop 来安装它，但前提是要添加epel 的yum源，具体请参考 CentOS yum 源的配置与使用。<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># rpm --import http://apt.sw.be/RPM-GPG-KEY.dag.txt</span></span><br><span class="line"><span class="preprocessor"># wget http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el6.rf.x86_64.rpm</span></span><br><span class="line"><span class="preprocessor"># rpm -K rpmforge-release-0.5.3-1.el6.rf.*.rpm</span></span><br><span class="line"><span class="preprocessor"># rpm -i rpmforge-release-0.5.3-1.el6.rf.*.rpm</span></span><br><span class="line"><span class="preprocessor"># yum install htop</span></span><br></pre></td></tr></table></figure></p>
<h1 id="htop_参数">htop 参数</h1><p>键入htop 命令，打开htop。</p>
<p><img src="http://user-image.logdown.io/user/1417/blog/1391/post/198662/EO2b6zTCT8eEv3oi8sRi_12224048-e798f9f6de94490885989b39970a8270.jpg" alt="12224048-e798f9f6de94490885989b39970a8270.jpg"></p>
<p>上面左上角显示CPU、内存、交换区的使用情况，右边显示任务、负载、开机时间，下面就是进程实时状况。<br>下面是 F1~F10 的功能和对应的字母快捷键。</p>
<table>
<thead>
<tr>
<th>Shortcut Key</th>
<th>Function Key</th>
<th>Description</th>
<th>中文说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>h, ?</td>
<td>F1</td>
<td>Invoke htop Help</td>
<td>查看htop使用说明</td>
</tr>
<tr>
<td>S</td>
<td>F2</td>
<td>Htop Setup Menu</td>
<td>htop 设定</td>
</tr>
<tr>
<td>/</td>
<td>F3</td>
<td>Search for a Process</td>
<td>搜索进程</td>
</tr>
<tr>
<td>\</td>
<td>F4</td>
<td>Incremental process filtering</td>
<td>增量进程过滤器</td>
</tr>
<tr>
<td>t</td>
<td>F5</td>
<td>Tree View</td>
<td>显示树形结构</td>
</tr>
<tr>
<td>&lt;, &gt;</td>
<td>F6</td>
<td>Sort by a column</td>
<td>选择排序方式</td>
</tr>
<tr>
<td>[</td>
<td>F7</td>
<td>Nice - (change priority)</td>
<td>可减少nice值，这样就可以提高对应进程的优先级</td>
</tr>
<tr>
<td>]</td>
<td>F8</td>
<td>Nice + (change priority)</td>
<td>可增加nice值，这样就可以降低对应进程的优先级</td>
</tr>
<tr>
<td>k</td>
<td>F9</td>
<td>Kill a Process</td>
<td>可对进程传递信号</td>
</tr>
<tr>
<td>q</td>
<td>F10</td>
<td>Quit htop</td>
<td>结束htop</td>
</tr>
</tbody>
</table>
<p><strong>命令行选项（COMMAND-LINE OPTIONS）</strong></p>
<p>-C —no-color　　　　 　　 使用一个单色的配色方案<br>-d —delay=DELAY　　　　 设置延迟更新时间，单位秒<br>-h —help　　　　　　  　　 显示htop 命令帮助信息<br>-u —user=USERNAME　　  只显示一个给定的用户的过程<br>-p —pid=PID,PID…　　　    只显示给定的PIDs<br>-s —sort-key COLUMN　    依此列来排序<br>-v –version　　　　　　　   显示版本信息</p>
<p><strong>交互式命令（INTERACTIVE COMMANDS）</strong></p>
<table>
<thead>
<tr>
<th>上下键或PgUP, PgDn</th>
<th>选定想要的进程</th>
</tr>
</thead>
<tbody>
<tr>
<td>左右键或Home, End</td>
<td>移动字段，当然也可以直接用鼠标选定进程；</td>
</tr>
<tr>
<td>Space</td>
<td>标记/取消标记一个进程。命令可以作用于多个进程，例如 “kill”，将应用于所有已标记的进程</td>
</tr>
<tr>
<td>U</td>
<td>取消标记所有进程</td>
</tr>
<tr>
<td>s</td>
<td>选择某一进程，按s:用strace追踪进程的系统调用</td>
</tr>
<tr>
<td>l</td>
<td>显示进程打开的文件: 如果安装了lsof，按此键可以显示进程所打开的文件</td>
</tr>
<tr>
<td>I</td>
<td>倒转排序顺序，如果排序是正序的，则反转成倒序的，反之亦然</td>
</tr>
<tr>
<td>+, -</td>
<td>When in tree view mode, expand or collapse subtree. When a subtree is collapsed a “+” sign shows to the left of the process name.</td>
</tr>
<tr>
<td>a (在有多处理器的机器上)</td>
<td>设置 CPU affinity: 标记一个进程允许使用哪些CPU</td>
</tr>
<tr>
<td>u</td>
<td>显示特定用户进程</td>
</tr>
<tr>
<td>M</td>
<td>按Memory 使用排序</td>
</tr>
<tr>
<td>P</td>
<td>按CPU 使用排序</td>
</tr>
<tr>
<td>T</td>
<td>按Time+ 使用排序</td>
</tr>
<tr>
<td>F</td>
<td>跟踪进程: 如果排序顺序引起选定的进程在列表上到处移动，让选定条跟随该进程。这对监视一个进程非常有用：通过这种方式，你可以让一个进程在屏幕上一直可见。使用方向键会停止该功能。</td>
</tr>
<tr>
<td>K</td>
<td>显示/隐藏内核线程</td>
</tr>
<tr>
<td>H</td>
<td>显示/隐藏用户线程</td>
</tr>
<tr>
<td>Ctrl-L</td>
<td>刷新</td>
</tr>
<tr>
<td>Numbers</td>
<td>PID 查找: 输入PID，光标将移动到相应的进程上</td>
</tr>
</tbody>
</table>
<h1 id="htop_使用">htop 使用</h1><h2 id="显示自带帮助">显示自带帮助</h2><p>鼠标点击Help或者按F1 显示自带帮助</p>
<p><img src="http://user-image.logdown.io/user/1417/blog/1391/post/198662/bbtswYdaQsO6nxRL7Gea_12224050-75be8605449248f999bde75c6697522f.jpg" alt="12224050-75be8605449248f999bde75c6697522f.jpg"></p>
<h2 id="htop_设定">htop 设定</h2><p>鼠标点击Setup或者按下F2 之后进入htop 设定的页面，Meters 页面设定了顶端的一些信息显示，顶端的显示又分为左右两侧，到底能显示些什么可以在最右侧那栏新增，要新增到上方左侧（F5）或是右侧（F6）都可以，这就是个人设定的范围了。这里多加了一个时钟。</p>
<p><img src="http://user-image.logdown.io/user/1417/blog/1391/post/198662/YPmTpe7bQBOnHyFrEaQE_12224052-570be85130854977aa4bc9f796fb0eb1.jpg" alt="12224052-570be85130854977aa4bc9f796fb0eb1.jpg"></p>
<p>上方左右两栏的显示方式分为Text Bar Graph Led 四种，下图我就把 cpu memory swap 改成文本模式显示，然后右栏的改成Bar 显示，clock 用LED方式显示。数据显示都差不多，只是这样看有点不习惯了。</p>
<p><img src="http://user-image.logdown.io/user/1417/blog/1391/post/198662/AxJXcJalQGal98aIFO3i_12224053-eca0d56c388240e495c0b3226ed45472.jpg" alt="12224053-eca0d56c388240e495c0b3226ed45472.jpg"></p>
<p>关于Display options 的设定，可要根据管理者自己的需要来设定。</p>
<p><img src="http://user-image.logdown.io/user/1417/blog/1391/post/198662/9v3VH9ClSouJgF6vH0X3_12224054-97538b88011d4b6fb49e7d48ec7b4263.jpg" alt="12224054-97538b88011d4b6fb49e7d48ec7b4263.jpg"></p>
<p>颜色选择，除了基本的颜色显示之外，htop 还提供了换面板的功能，其实也只是改变一些色彩显示的设定，虽然说不能自定义到细部的颜色显示，但是至少提供了几种风格可以选择。</p>
<p><img src="http://user-image.logdown.io/user/1417/blog/1391/post/198662/Rk8VkpY2RI6pM4Qodmoe_12224056-2f6114304f37492095545a4ad6a68986.jpg" alt="12224056-2f6114304f37492095545a4ad6a68986.jpg"></p>
<p>最后一项的设定是调整 Columns 的显示，就是在一般htop 指令进来希望可以看到的什么样的数据及信息，字段的调整可以在这边做个人化的设定，一般使用系统默认值就好了。</p>
<p><img src="http://user-image.logdown.io/user/1417/blog/1391/post/198662/hxFqEnM7RJO7KmynsnHu_12224059-a5ece1fdc31e420da897d01167e97550.jpg" alt="12224059-a5ece1fdc31e420da897d01167e97550.jpg"></p>
<h2 id="搜索进程">搜索进程</h2><p>鼠标点击Search 或者按下F3 或者输入”/“， 输入进程名进行搜索，例如搜索ssh</p>
<p><img src="http://user-image.logdown.io/user/1417/blog/1391/post/198662/tpHBqvDqSCyZsmVipLSy_12224101-da92613d580148e7a74b5bde960bbbb8.jpg" alt="12224101-da92613d580148e7a74b5bde960bbbb8.jpg"></p>
<h2 id="过滤器">过滤器</h2><p>按下F4，进入过滤器，相当于关键字搜索，不区分大小写，例如过滤dev</p>
<p><img src="http://user-image.logdown.io/user/1417/blog/1391/post/198662/N4ST8R9wSh2X2l5EQ6Tt_12224103-ee01abbe5a7d4f5388057a52bd52e109.jpg" alt="12224103-ee01abbe5a7d4f5388057a52bd52e109.jpg"></p>
<h2 id="显示树形结构">显示树形结构</h2><p>输入”t”或按下F5，显示树形结构，意思跟pstree 差不多，能看到所有程序树状执行的结构，这对于系统管理来说相当方便，理清程序是如何产生的，当然树状结构的浏览也可以依照其他数据来排序。</p>
<p><img src="http://user-image.logdown.io/user/1417/blog/1391/post/198662/1ltROwUtTz6WPjCs0PrQ_12224105-44b98e747b494234929f8af4e3eeb5e4.jpg" alt="12224105-44b98e747b494234929f8af4e3eeb5e4.jpg"></p>
<h2 id="选择排序方式">选择排序方式</h2><p>按下F6 就可以选择依照什么来排序，最常排序的内容就是cpu 和memory 吧！</p>
<p><img src="http://user-image.logdown.io/user/1417/blog/1391/post/198662/qShoFiiTICm4u6C9kpWg_12224111-2f34d96612bd420ebcf9471c7339fc63.jpg" alt="12224111-2f34d96612bd420ebcf9471c7339fc63.jpg"></p>
<h2 id="操作进程">操作进程</h2><p>F7、F8分别对应nice-和nice+，F9对应kill给进程发信号，选好信号回车就OK了</p>
<p><img src="http://user-image.logdown.io/user/1417/blog/1391/post/198662/9cuJq5SGQfm4Jt87QcnB_12224113-0e383c20b0e74196a393586b72a67ba1.jpg" alt="12224113-0e383c20b0e74196a393586b72a67ba1.jpg"></p>
<h2 id="显示某个用户的进程，在左侧选择用户">显示某个用户的进程，在左侧选择用户</h2><p>输入”u”，在左侧选择用户</p>
<p><img src="http://user-image.logdown.io/user/1417/blog/1391/post/198662/Rj7joHcVQLai0GctiCHa_12224116-5b7ca92b8c644464a65a11204e346f49.jpg" alt="12224116-5b7ca92b8c644464a65a11204e346f49.jpg"></p>
<h1 id="Alias_top">Alias top</h1><p>也许你用惯了top，我们也可以用top来打开htop。</p>
<p>编辑/root/.bashrc文件，添加如下代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="operator">-f</span> /usr/<span class="built_in">local</span>/bin/htop ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">alias</span> top=’/usr/<span class="built_in">local</span>/bin/htop’</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<p><code>source /root/.bashrc</code></p>
<p>本文转自  <a href="http://www.cnblogs.com/mchina/archive/2013/03/15/2858041.html" target="_blank" rel="external">http://www.cnblogs.com/mchina/archive/2013/03/15/2858041.html</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.harrycode.com/2014/05/12/change-replacing-the-top-process-management-tools-under-linux-htop/" data-id="cibq3ipoo000wgh6ak1stw5o7" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tools/">Tools</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-installation-configuration-and-use-of-mysqlnd-ms" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/10/installation-configuration-and-use-of-mysqlnd-ms/" class="article-date">
  <time datetime="2014-05-10T02:21:00.000Z" itemprop="datePublished">2014-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/10/installation-configuration-and-use-of-mysqlnd-ms/">Mysqlnd_ms的安装配置与使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>公司最近需要一个扩展性良好的Mysql主从分离方案，老大要求对业务层的代码改动要小。<br>业务层代码改动小，意味着要在连接层直接把读／写请求分发，而不是到业务层通过”SQL识别”的来分离。<br>脑子里有两套方案， Mysqlnd_ms 和 Mysql-Proxy。两个方案各有优／缺点</p>
<p><strong>Mysqlnd_ms</strong></p>
<p>优点：</p>
<pre><code><span class="bullet">1. </span>PHP官方推荐的扩展，PECL安装方便
</code></pre><ol>
<li>基于PHP扩展对SQL进行解析，进而分离请求，对业务层代码改动小，性能损失也小</li>
<li>扩展本身已经在社区打滚有些年头了，较稳定，口碑好</li>
<li>入门级文档清晰，易配置易上手</li>
<li>有连接池</li>
<li><p>功能强大，支持SQL Hint， 事务，最终／Session/强一致性等场景</p>
<p>缺点：</p>
<ol>
<li>基于扩展的封装，扩展的实现对上层透明。扩展本身缺乏debug工具， 所以真遇到问题可能比较难查</li>
</ol>
</li>
<li>Failover 策略较基础</li>
<li>缺乏中文文档</li>
<li><p>强一致性的场景会有些坑</p>
<p><strong>Mysql-Proxy</strong></p>
<p>优点:</p>
<ol>
<li>来自Mysql官方的解决方案</li>
</ol>
</li>
<li>性能好，资源占用少</li>
<li>有连接池</li>
<li>配置简单／文档众多</li>
<li><p>应有广泛，口碑好</p>
<p>缺点:</p>
<ol>
<li>需要第三方脚本(Lua)支持</li>
</ol>
</li>
</ol>
<p>鉴于”对业务层代码改动要小”这个需求，以及笔者对Mysql-Proxy 使用较少，所以在简单比较之后，果断选择了Mysqlnd_ms。</p>
<h1 id="安装">安装</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>wget http://pecl.php.net/get/mysqlnd_ms-1.5.2.tgz </span><br><span class="line"><span class="bullet">2. </span>tar xzvf mysqlnd_ms-1.5.2.tgz</span><br><span class="line"><span class="bullet">3. </span>cd mysqlnd_ms-1.5.2</span><br><span class="line"><span class="bullet">4. </span>/path/to/phpize</span><br><span class="line"><span class="bullet">5. </span>./configure --enable-mysqlnd-ms --with-php-config=/usr/local/php/bin/php-config</span><br><span class="line"><span class="bullet">6. </span>make</span><br><span class="line"><span class="bullet">7. </span>make install</span><br><span class="line"><span class="bullet">8. </span>sudo /etc/init.d/php-fpm restart</span><br><span class="line"><span class="bullet">9. </span>/path/to/php -m | grep mysql #看到"mysqlnd_ms"扩展表示安装成功</span><br></pre></td></tr></table></figure>
<h1 id="配置">配置</h1><h2 id="1-_创建配置文件_/usr/local/etc/php/php-d/mysqlnd_ms-ini">1. 创建配置文件 /usr/local/etc/php/php.d/mysqlnd_ms.ini</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">extension=</span><span class="string">"/usr/local/php-5.5.9/lib/php/extensions/no-debug-non-zts-20121212/mysqlnd_ms.so"</span> </span><br><span class="line">; 启动mysqlnd_ms</span><br><span class="line">mysqlnd_ms.<span class="variable">enable=</span><span class="number">1</span></span><br><span class="line">; 加载的主从配置文件</span><br><span class="line">mysqlnd_ms.<span class="variable">config_file=</span><span class="string">"/usr/local/etc/php/php.d/mysqlnd_ms.conf"</span> </span><br><span class="line">; 是否禁用读写分离</span><br><span class="line">mysqlnd_ms.<span class="variable">disable_rw_split=</span><span class="number">0</span></span><br><span class="line">; mysqlnd 日志输出格式(线上环境可选)</span><br><span class="line">mysqlnd.<span class="variable">debug=</span><span class="string">"d:t:x:A,/tmp/mysqlnd.trace"</span> </span><br><span class="line">;<span class="variable">SERVER_QUERY_NO_GOOD_INDEX_USED=</span><span class="number">16</span></span><br><span class="line">;<span class="variable">SERVER_QUERY_NO_INDEX_USED=</span><span class="number">32</span></span><br><span class="line">;<span class="variable">SERVER_QUERY_WAS_SLOW=</span><span class="number">1024</span></span><br><span class="line">; 日志掩码</span><br><span class="line">mysqlnd.<span class="variable">log_mask=</span><span class="number">1072</span></span><br><span class="line"></span><br><span class="line">; 网络读缓存大小</span><br><span class="line">; <span class="number">64</span>K</span><br><span class="line">mysqlnd.<span class="variable">net_read_buffer_size=</span><span class="number">65536</span></span><br><span class="line">; 网络读等待时间</span><br><span class="line">mysqlnd.<span class="variable">net_read_timeout=</span><span class="number">600</span></span><br></pre></td></tr></table></figure>
<h2 id="2-_创建主从策略文件_/usr/local/etc/php/php-d/mysqlnd_ms-conf_(位置由mysqlnd_ms-ini指定)">2. 创建主从策略文件 /usr/local/etc/php/php.d/mysqlnd_ms.conf (位置由mysqlnd_ms.ini指定)</h2><p>Demo 主从写成了同一个库<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">    <span class="string">"master-slave"</span>: <span class="collection">&#123; // section 对应一组服务</span><br><span class="line">        <span class="string">"master"</span>: <span class="collection">&#123; // 主库配置<span class="list">(默认主库只包含一项)</span></span><br><span class="line">            <span class="string">"master_0"</span>: <span class="collection">&#123;</span><br><span class="line">                <span class="string">"host"</span>: <span class="string">"192.168.100.100"</span>,//host必选 其他可为空。 扩展优先使用本文件中的配置，如果为空，再去使用php连接mysql时使用的参数</span><br><span class="line">                <span class="string">"port"</span>: <span class="string">"3306"</span>,</span><br><span class="line">                <span class="string">"socket"</span>: <span class="string">"\/var\/data\/mysql\/mysql.sock"</span>,</span><br><span class="line">                <span class="string">"db"</span>: <span class="string">"master-slave"</span>,</span><br><span class="line">                <span class="string">"user"</span>: <span class="string">"root"</span>,</span><br><span class="line">                <span class="string">"password"</span>: <span class="string">""</span>,</span><br><span class="line">                <span class="string">"connect_flags"</span>: <span class="number">0</span></span><br><span class="line">            &#125;</span></span><br><span class="line">        &#125;</span>,</span><br><span class="line">        <span class="string">"slave"</span>: <span class="collection">&#123; // 从库配置<span class="list">(可配置多项，slave为空会在php处报warning)</span></span><br><span class="line">            <span class="string">"slave_0"</span>: <span class="collection">&#123;</span><br><span class="line">                <span class="string">"host"</span>: <span class="string">"192.168.100.101"</span>,</span><br><span class="line">                <span class="string">"port"</span>: <span class="string">"3306"</span>,</span><br><span class="line">                <span class="string">"socket"</span>: <span class="string">"\/var\/data\/mysql\/mysql.sock"</span>,</span><br><span class="line">                <span class="string">"db"</span>: <span class="string">"master-slave"</span>,</span><br><span class="line">                <span class="string">"user"</span>: <span class="string">"root"</span>,</span><br><span class="line">                <span class="string">"password"</span>: <span class="string">""</span>,</span><br><span class="line">                <span class="string">"connect_flags"</span>: <span class="number">0</span>                                                                   </span><br><span class="line">            &#125;</span>,</span><br><span class="line">            <span class="string">"slave_1"</span>: <span class="collection">&#123;</span><br><span class="line">                <span class="string">"host"</span>: <span class="string">"192.168.100.102"</span>,</span><br><span class="line">                <span class="string">"port"</span>: <span class="string">"3306"</span>,</span><br><span class="line">                <span class="string">"socket"</span>: <span class="string">"\/var\/data\/mysql\/mysql.sock"</span>,</span><br><span class="line">                <span class="string">"db"</span>: <span class="string">"master-slave"</span>,</span><br><span class="line">                <span class="string">"user"</span>: <span class="string">"root"</span>,</span><br><span class="line">                <span class="string">"password"</span>: <span class="string">""</span>,</span><br><span class="line">                <span class="string">"connect_flags"</span>: <span class="number">0</span>                        </span><br><span class="line">            &#125;</span>,</span><br><span class="line">        &#125;</span>,   </span><br><span class="line">        <span class="string">"lazy_connections"</span>: <span class="number">1</span>, //只在执行sql之前才连接数据库</span><br><span class="line">        <span class="string">"server_charset"</span> : <span class="string">"utf8"</span> //服务端编码</span><br><span class="line">    &#125;</span>   </span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>/etc/init.d/php-fpm restart  #重启fpm生效</p>
<h2 id="3-_一些基本的参数说明">3. 一些基本的参数说明</h2><table>
<thead>
<tr>
<th style="text-align:left">参数名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">master</td>
<td style="text-align:left">主库配置</td>
</tr>
<tr>
<td style="text-align:left">host</td>
<td style="text-align:left">ip or hostname</td>
</tr>
<tr>
<td style="text-align:left">port</td>
<td style="text-align:left">端口</td>
</tr>
<tr>
<td style="text-align:left">socket</td>
<td style="text-align:left">连接套接字</td>
</tr>
<tr>
<td style="text-align:left">db</td>
<td style="text-align:left">库名字</td>
</tr>
<tr>
<td style="text-align:left">user</td>
<td style="text-align:left">用户名</td>
</tr>
<tr>
<td style="text-align:left">password</td>
<td style="text-align:left">用户密码</td>
</tr>
<tr>
<td style="text-align:left">connect_flags</td>
<td style="text-align:left">连接参数</td>
</tr>
<tr>
<td style="text-align:left">slave</td>
<td style="text-align:left">从库配置</td>
</tr>
<tr>
<td style="text-align:left">global_transaction_id_injection</td>
<td style="text-align:left">GTID的配置 详见 <a href="http://cn2.php.net/manual/zh/mysqlnd-ms.plugin-ini-json.php" target="_blank" rel="external">http://cn2.php.net/manual/zh/mysqlnd-ms.plugin-ini-json.php</a></td>
</tr>
<tr>
<td style="text-align:left">filter</td>
<td style="text-align:left">选择从库的策略 random/roundrobin/user/user_multi/node_groups 策略详情详见 <a href="http://cn2.php.net/manual/zh/mysqlnd-ms.plugin-ini-json.php" target="_blank" rel="external">http://cn2.php.net/manual/zh/mysqlnd-ms.plugin-ini-json.php</a></td>
</tr>
<tr>
<td style="text-align:left">failover</td>
<td style="text-align:left">故障转移 disabled (默认), master(读从失败就连主库),loop_before_master(读从失败轮寻其他从库再读主库)</td>
</tr>
<tr>
<td style="text-align:left">lazy_connections</td>
<td style="text-align:left">被动连接</td>
</tr>
<tr>
<td style="text-align:left">server_charset</td>
<td style="text-align:left">服务端字符集</td>
</tr>
<tr>
<td style="text-align:left">trx_stickiness</td>
<td style="text-align:left">事务控制策略</td>
</tr>
</tbody>
</table>
<h1 id="使用">使用</h1><ol>
<li><p>通常情况下，使用mysqlnd_ms 不需要改动业务端的代码，只需要在连接数据库时，使用配置中的host，即可实现主从分离，如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$dbh</span>  = <span class="keyword">new</span>  PDO ( <span class="string">'mysql:host=master-slave;dbname=master-slave'</span> ,  <span class="string">'root'</span> ,  <span class="string">''</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Master */</span></span><br><span class="line">    <span class="keyword">foreach</span>( <span class="variable">$dbh</span> -&gt; query ( <span class="string">'show tables'</span> ) <span class="keyword">as</span>  <span class="variable">$row</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        print_r ( <span class="variable">$row</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Slave */</span></span><br><span class="line">    <span class="keyword">foreach</span>( <span class="variable">$dbh</span> -&gt; query ( <span class="string">'SELECT * from test LIMIT 1'</span> ) <span class="keyword">as</span>  <span class="variable">$row</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        print_r ( <span class="variable">$row</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$dbh</span>  =  <span class="keyword">null</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> ( PDOException <span class="variable">$e</span> )</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">print</span>  <span class="string">"Error!: "</span>  .  <span class="variable">$e</span> -&gt; getMessage () .  <span class="string">"&lt;br/&gt;"</span> ;</span><br><span class="line">        <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">Exception</span> <span class="variable">$e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    var_dump(<span class="variable">$e</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>采取主从分离，就一定存在着同步延迟的问题。 在一个繁忙的服务中，主／从同步会存在延迟。mysqlnd_ms 将这种场景细分为：</p>
</li>
</ol>
<ul>
<li>最终一致性：用户可能无法立即看到自己写入的数据</li>
<li>session一致性：用户自己可以立即看到自己写入的数据</li>
<li>强一致性：所有的用户都可以立即看到其他用户的写入的数据</li>
</ul>
<p>mysqlnd_ms 针对不同的场景，提供不同的策略。如果对延迟比较敏感(如：用户提交表单后，页面立即跳转展示用户提交的数据)，在编码的过程中还需要参考下述文档</p>
<ol>
<li>SQL Hints: <a href="http://cn2.php.net/manual/zh/mysqlnd-ms.quickstart.sqlhints.php" target="_blank" rel="external">http://cn2.php.net/manual/zh/mysqlnd-ms.quickstart.sqlhints.php</a></li>
<li>事务： <a href="http://cn2.php.net/manual/zh/mysqlnd-ms.quickstart.transactions.php" target="_blank" rel="external">http://cn2.php.net/manual/zh/mysqlnd-ms.quickstart.transactions.php</a></li>
<li>服务级别和一致性： <a href="http://cn2.php.net/manual/zh/mysqlnd-ms.quickstart.qos-consistency.php" target="_blank" rel="external">http://cn2.php.net/manual/zh/mysqlnd-ms.quickstart.qos-consistency.php</a></li>
<li>Global transaction IDs (GTID)： <a href="http://cn2.php.net/manual/zh/mysqlnd-ms.quickstart.gtid.php" target="_blank" rel="external">http://cn2.php.net/manual/zh/mysqlnd-ms.quickstart.gtid.php</a></li>
<li>Cache integration： <a href="http://cn2.php.net/manual/zh/mysqlnd-ms.quickstart.cache.php" target="_blank" rel="external">http://cn2.php.net/manual/zh/mysqlnd-ms.quickstart.cache.php</a></li>
</ol>
<h1 id="一些陷阱">一些陷阱</h1><ol>
<li>Mysqlnd_ms 的行为是这样的。 所有的Select 操作会访问从库， 除Select 其他的所有操作都访问主库，包括(SHOW, SET等)。<br>所以习惯使用mysql变量来编程的同学要注意了，如：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">set</span> @id=<span class="number">2</span>;</span>(主库)</span><br><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id:=@id（从库）;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的第二条语句会因为在从库找不到id这个变量而报错， 这种情况要SQL Hint 给Mysql一些提示</p>
<ol>
<li>Mysqlnd_ms 并不支持 <em>mysqli</em> 的multi_statements。 如使用mysqli_multi_query() 来批量执行SQL<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span> = <span class="string">"SELECT * FROM &#123;$table&#125; WHERE .."</span>;</span><br><span class="line"><span class="variable">$sql</span> .= <span class="string">"INSERT INTO &#123;$table&#125;"</span>;</span><br><span class="line"><span class="variable">$mysqli</span> -&gt; multi_query (<span class="variable">$sql</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的第一条SQL会被识别为访问从库，Mysqlnd_ms 无法拆分一个批量操作，所以第二条Insert 也会进从库而造成数据不一致。</p>
<ol>
<li>事务的默认行为也和上述第二点一样，无法拆分一个事务，所以”读／写”请求尽量不要写进同一个事务中。如果一定要写，要使用SQL Hint 给Mysqlnd_ms 一些提示。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.harrycode.com/2014/05/10/installation-configuration-and-use-of-mysqlnd-ms/" data-id="cibq3ipom000tgh6aahsemags" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-simple-steps-to-build-cool-vim-development-environment" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/05/simple-steps-to-build-cool-vim-development-environment/" class="article-date">
  <time datetime="2014-05-05T04:05:00.000Z" itemprop="datePublished">2014-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/05/simple-steps-to-build-cool-vim-development-environment/">简单几步搭建超酷的Vim开发环境</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>无论是在前公司还是在新公司，总有同事路过我的工位，对着我的Vim界面赞叹不已，然后述说自己当年下好大决心工作在Vim环境中，后来“创业未半而中道崩殂”的苦楚… -_-# 后来我发现这些人多半不是卡在Vim的基本操作，而是抱怨Vim不能满足他们的各种开发需求，也没时间去了解或配置一些常规插件。望着一些其他的IDE内置了自己梦寐以求的功能，最终缴械投降。</p>
<p>本着践行／传播Vim这一利器的主旨，把自己搭建Vim开发环境的一些经验分享出来。其实类似的文章已经很多了，其中不乏非常专业的文章。但是其实”懒人”真正需要的是一个可以”Setup-&gt;Next-&gt;Next-&gt;Finish”，然后”哇～ Amazing！！”的Vim集成开发环境。我们就来看看，如何通过简单几步，让您拥有一个超Cool并且可以到处炫耀的Vim环境～ :)</p>
<p>现在我们要祭出一件神器，也是本文中要着重介绍的一款软件 —— spf13-vim (<a href="https://github.com/spf13/spf13-vim" target="_blank" rel="external">https://github.com/spf13/spf13-vim</a>)。 这东西是一个Vim的集成开发环境，内置集成很多码农们常用的插件，基于bundle的方式非常方便扩展以及更新，是初学者们了解Vim以及精通Vim的一个很好的出发点，极大的降低了Vim使用的门槛。</p>
<h1 id="安装_spf13-vim">安装 spf13-vim</h1><h2 id="官方的安装步骤">官方的安装步骤</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http<span class="variable">s:</span>//<span class="keyword">j</span>.mp/spf13-vim3 -L &gt; spf13-<span class="keyword">vim</span>.<span class="keyword">sh</span> &amp;&amp; <span class="keyword">sh</span> spf13-<span class="keyword">vim</span>.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<p>官方的安装步骤很简便，但是综合了我国GFW的国情后，稍显得有些问题。官方的安装脚本会自动执行Vundle安装内置的插件，Vundle会自动Clone GitHub上的这些扩展，但是在我国从Github上clone代码还是很慢的，默认安装的插件也比较多，整个安装过程就比较慢。另外有些默认插件可能是你不需要的，都安装了用不上，费电不说，其实拖慢Vim的执行速度。下面我们看看怎样做一些设置。</p>
<h2 id="自定义的安装步骤">自定义的安装步骤</h2><p>首先我们只下载安装脚本，但不要默认执行<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http<span class="variable">s:</span>//<span class="keyword">j</span>.mp/spf13-vim3 -L &gt; spf13-<span class="keyword">vim</span>.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></p>
<p>编辑spf13-vim.sh, 可以在最后看到这样一行, 看setup_vundle的函数定义，知道这个函数就是执行vundle 安装插件的命令，我们用 <code>&quot;</code> 注释掉这一行， 然后给脚本执行权限并执行spf安装脚本。chmod u+x spf13-vim.sh ＆＆ sh spf13-vim.sh<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" setup_vundle    "</span>Now updating/installing plugins using Vundle<span class="string">"</span></span><br></pre></td></tr></table></figure></p>
<p>很快我们看到spf13安装完成了，在home目录下执行 ls -lha | grep vim  可以看到spf13安装的vim配置文件的软链接<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx   <span class="number">1</span> harry harry   <span class="number">33</span> May  <span class="number">5</span> <span class="number">11</span>:<span class="number">27</span> <span class="class">.vimrc</span> -&gt; /home/tianhai/.spf13-vim-<span class="number">3</span>/<span class="class">.vimrc</span></span><br><span class="line">lrwxrwxrwx   <span class="number">1</span> harry harry   <span class="number">40</span> May  <span class="number">5</span> <span class="number">11</span>:<span class="number">27</span> <span class="class">.vimrc</span><span class="class">.before</span> -&gt; /home/tianhai/.spf13-vim-<span class="number">3</span>/<span class="class">.vimrc</span><span class="class">.before</span></span><br><span class="line">-rw-r--r--   <span class="number">1</span> harry harry  <span class="number">143</span> May  <span class="number">5</span> <span class="number">11</span>:<span class="number">45</span> <span class="class">.vimrc</span><span class="class">.before</span><span class="class">.local</span></span><br><span class="line">lrwxrwxrwx   <span class="number">1</span> harry harry   <span class="number">41</span> May  <span class="number">5</span> <span class="number">11</span>:<span class="number">27</span> <span class="class">.vimrc</span><span class="class">.bundles</span> -&gt; /home/tianhai/.spf13-vim-<span class="number">3</span>/<span class="class">.vimrc</span><span class="class">.bundles</span></span><br><span class="line">lrwxrwxrwx   <span class="number">1</span> harry harry   <span class="number">31</span> May  <span class="number">5</span> <span class="number">11</span>:<span class="number">27</span> <span class="class">.vim</span> -&gt; /home/tianhai/.spf13-vim-<span class="number">3</span>/.vim</span><br></pre></td></tr></table></figure></p>
<p>编辑 .vimrc.bundles 这个文件,可以看到类似的代码块， 这个代码块就是告诉Vundle来安装哪些扩展<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" Misc &#123;</span><br><span class="line"></span>    <span class="keyword">if</span> <span class="built_in">count</span>(<span class="variable">g:spf13_bundle_groups</span>, <span class="string">'misc'</span>)</span><br><span class="line">        Bundle <span class="string">'tpope/vim-markdown'</span></span><br><span class="line">        Bundle <span class="string">'spf13/vim-preview'</span></span><br><span class="line">        Bundle <span class="string">'tpope/vim-cucumber'</span></span><br><span class="line">        Bundle <span class="string">'quentindecock/vim-cucumber-align-pipes'</span></span><br><span class="line">        Bundle <span class="string">'Puppet-Syntax-Highlighting'</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">" &#125;</span><br></pre></td></tr></table></figure></p>
<p>回到 100行左右， 可以看到如下的配置<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" In your .vimrc.before.local file</span><br><span class="line"></span><span class="string">" list only the plugin groups you will use</span><br><span class="line"></span><span class="keyword">if</span> !exists(<span class="string">'g:spf13_bundle_groups'</span>)</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g:spf13_bundle_groups</span>=[<span class="string">'general'</span>, <span class="string">'writing'</span>, <span class="string">'neocomplcache'</span>, <span class="string">'programming'</span>, <span class="string">'php'</span>, <span class="string">'ruby'</span>, <span class="string">'python'</span>, <span class="string">'twig'</span>, <span class="string">'javascript'</span>, <span class="string">'html'</span>, <span class="string">'misc'</span>,]</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p>
<p>spf13_bundle_groups 这个变量用来控制Vundle加载那些模块，spf默认安装了一些php/ruby/python／html/js的扩展，就像注释中说的，我们可以通过覆盖这个变量来自定义Vundle加载的扩展。譬如我想安装go 但我的工作中不使用twig，我就可以在.vimrc.before.local 通过覆盖 spf13_bundle_groups 变量的方式来做自定义。下面是我的定义：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">echo</span> "<span class="tag">let</span> <span class="rule"><span class="attribute">g</span>:<span class="value">spf13_bundle_groups=[<span class="string">'general'</span>, <span class="string">'writing'</span>, <span class="string">'neocomplcache'</span>, <span class="string">'programming'</span>, <span class="string">'php'</span>, <span class="string">'ruby'</span>, <span class="string">'python'</span>, <span class="string">'javascript'</span>, <span class="string">'go'</span>, <span class="string">'html'</span>, <span class="string">'misc'</span>,]<span class="string">" &gt;&gt; .vimrc.before.local</span></span></span></span><br></pre></td></tr></table></figure>
<p>之后我们执行来激活Vundle开始安装扩展，其实使用vim打开任意文件，执行<code>:PluginInstall</code>也是一样的，看个人喜好<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="string">\</span></span><br><span class="line">    -u <span class="string">"$HOME/.vimrc.bundles"</span> <span class="string">\</span></span><br><span class="line">    <span class="string">"+set nomore"</span> <span class="string">\</span></span><br><span class="line">    +BundleInstall! <span class="string">\</span></span><br><span class="line">    +BundleClean <span class="string">\</span></span><br><span class="line">    +qall</span><br></pre></td></tr></table></figure></p>
<p>执行后我们能看到Vundle开始安装扩展，综合了GFW的国情后，其实还是不快，给点耐心吧～ :)</p>
<p><img src="http://user-image.logdown.io/user/1417/blog/1391/post/197145/vQ2OrN4uTtiIl6MWKMvJ_2014-05-05%2013:31:04%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="Vundle Install"></p>
<p>安装完成后，恭喜你，你已经拥有了一个功能强大的Vim集成开发环境了。</p>
<h1 id="Vundle">Vundle</h1><p>spf13 默认使用 Vundle (<a href="https://github.com/gmarik/Vundle.vim" target="_blank" rel="external">https://github.com/gmarik/Vundle.vim</a>)来管理vim插件</p>
<p>关于Vundle的使用，可以参考这篇博客 <a href="http://foocoder.com/blog/mei-ri-vimcha-jian-kai-pian-zhi-vundle.html" target="_blank" rel="external">每日vim插件—开篇之vundle</a>，介绍的很详细。PS:博主每日都会介绍一款vim插件，vim功底深厚，讲的也很详细，建议大家follow。</p>
<p>回到spf13中， 我们可以通过扩展 ~/.vimrc.bundles.local 来追加一些我们偏爱但是spf13没有内置的插件，语法参考~/.vimrc.bundles 或者参考上面的博客。</p>
<h1 id="一些插件">一些插件</h1><h2 id="关于配色">关于配色</h2><p>spf13默认的配色方案是 solarized， 如果需要选择其他的配色方案，可以通过下面的命令来定义<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> colorscheme &#123;<span class="variable">$colorscheme</span>&#125;  &gt;&gt; ~/.vimrc.local</span><br></pre></td></tr></table></figure></p>
<p>spf13 内置了  vim-colors-solarized (<a href="https://github.com/altercation/vim-colors-solarized" target="_blank" rel="external">https://github.com/altercation/vim-colors-solarized</a>) 以及 vim-colors (<a href="https://github.com/spf13/vim-colors/" target="_blank" rel="external">https://github.com/spf13/vim-colors/</a>) 两个配色插件，集中了上百种配色，可以从中选择. 放置在  ~/.vim/bundle/vim-colors/ 以及 ~/.vim/bundle/vim-colorschemes/ 两个目录中。</p>
<p>我个人比较偏爱 molokai / peaksea / 256-jungle, 其中molokai在GVim下展示最好，256-jungle在终端下展示最好。</p>
<h2 id="关于字体">关于字体</h2><p>我个人偏爱  Source-Code-Pro   <a href="Source-Code-Pro   https://github.com/adobe/source-code-pro">https://github.com/adobe/source-code-pro</a></p>
<p>安装方法可以参考：<a href="https://github.com/adobe/source-code-pro/issues/17#issuecomment-8967116" target="_blank" rel="external">https://github.com/adobe/source-code-pro/issues/17#issuecomment-8967116</a></p>
<h2 id="BufExplore">BufExplore</h2><p><a href="https://github.com/vim-scripts/bufexplorer.zip" target="_blank" rel="external">https://github.com/vim-scripts/bufexplorer.zip</a><br><code>:BufExplorer</code> 列出已经打开的文件, 选择后跳转 </p>
<p><img src="http://user-image.logdown.io/user/1417/blog/1391/post/197145/EQahWRUvQAGIwf3lc3c7_bufexplore.png" alt="bufexplore.png"></p>
<h2 id="vim-indent-guides">vim-indent-guides</h2><p><a href="https://github.com/nathanaelkane/vim-indent-guides" target="_blank" rel="external">https://github.com/nathanaelkane/vim-indent-guides</a><br>用来优化展示缩进， 在GVim 中这个插件展示的很完美，可以自动识别背景色来展示。但是在终端环境中，只能显示dark/light两种模式，缩进看起来一块一块的，比较难看，我习惯默认关闭它。<br>在.vimrc.local 中添加 <code>let g:indent_guides_auto_colors = 0</code>. 我们可以通过<code>&lt;Leader&gt;ig</code>来开启它, spf13的默认<leader>键为 <code>,</code>。</leader></p>
<h2 id="NERDTree">NERDTree</h2><p><a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="external">https://github.com/scrooloose/nerdtree</a></p>
<p>Vim的文件浏览器。 通过<code>:NERDTreeToggle</code> 来唤出，我习惯把它绑定到F5上，下面是我的配置<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let <span class="constant">NERDTreeChDirMode </span>= <span class="number">2</span></span><br><span class="line">let <span class="constant">NERDTreeWinSize </span>= <span class="number">30</span></span><br><span class="line">nmap &lt;<span class="constant">F5&gt;</span>  <span class="symbol">:NERDTreeToggle&lt;CR&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="ctrlp">ctrlp</h2><p><a href="https://github.com/kien/ctrlp.vim" target="_blank" rel="external">https://github.com/kien/ctrlp.vim</a></p>
<p>Vim中的文件查找器，类似sublime的ctrl-p，几个常用命令<br><code>：CtrlP</code> or <code>:CtrlP [starting-directory]</code>  启动ctrlp<br><code>:CtrlPBuffer</code> or <code>:CtrlPMRU</code> 启动ctrlp并只在buffer/mru中进行查找<br><code>:CtrlPMixed</code> 在 Files, Buffers 和 MRU 中进行混合查找</p>
<p>在ctrlp开启后，还有一些快捷键<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Press &lt;F5&gt; <span class="keyword">to</span> purge the cache <span class="keyword">for</span> the current directory <span class="keyword">to</span> get <span class="keyword">new</span> files, remove deleted files <span class="keyword">and</span> apply <span class="keyword">new</span> ignore options.</span><br><span class="line">Press &lt;c-f&gt; <span class="keyword">and</span> &lt;c-b&gt; <span class="keyword">to</span> cycle between modes.</span><br><span class="line">Press &lt;c-d&gt; <span class="keyword">to</span> switch <span class="keyword">to</span> filename only search instead <span class="keyword">of</span> full path.</span><br><span class="line">Press &lt;c-r&gt; <span class="keyword">to</span> switch <span class="keyword">to</span> regexp mode.</span><br><span class="line"><span class="keyword">Use</span> &lt;c-j&gt;, &lt;c-k&gt; <span class="keyword">or</span> the arrow keys <span class="keyword">to</span> navigate the result list.</span><br><span class="line"><span class="keyword">Use</span> &lt;c-t&gt; <span class="keyword">or</span> &lt;c-v&gt;, &lt;c-x&gt; <span class="keyword">to</span> <span class="keyword">open</span> the selected entry <span class="keyword">in</span> a <span class="keyword">new</span> tab <span class="keyword">or</span> <span class="keyword">in</span> a <span class="keyword">new</span> split.</span><br><span class="line"><span class="keyword">Use</span> &lt;c-n&gt;, &lt;c-p&gt; <span class="keyword">to</span> <span class="keyword">select</span> the <span class="keyword">next</span>/previous <span class="typename">string</span> <span class="keyword">in</span> the prompt<span class="attribute">'s</span> history.</span><br><span class="line"><span class="keyword">Use</span> &lt;c-y&gt; <span class="keyword">to</span> create a <span class="keyword">new</span> <span class="keyword">file</span> <span class="keyword">and</span> its parent directories.</span><br><span class="line"><span class="keyword">Use</span> &lt;c-z&gt; <span class="keyword">to</span> mark/unmark multiple files <span class="keyword">and</span> &lt;c-o&gt; <span class="keyword">to</span> <span class="keyword">open</span> them.</span><br></pre></td></tr></table></figure></p>
<h2 id="surround">surround</h2><p><a href="https://github.com/tpope/vim-surround" target="_blank" rel="external">https://github.com/tpope/vim-surround</a><br>用来处理包围符号的插件，包括’ “ { } [ ]等<br>下面是一些基本的用法<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">**cs: 包围符号替换**</span><br><span class="line"><span class="string">'hello'</span> =&gt; cs<span class="string">'" =&gt;"hello"</span><br><span class="line">'</span>hello<span class="string">' =&gt; cs'</span>&lt;q&gt; =&gt;&lt;q&gt;hello&lt;/q&gt;</span><br><span class="line">&lt;q&gt;hello&lt;/q&gt; =&gt; cst<span class="string">' =&gt; '</span>hello<span class="string">'</span><br><span class="line">**ds: 去掉包围符号**</span><br><span class="line">'</span>hello<span class="string">' =&gt; ds'</span> =&gt; hello</span><br><span class="line">**ys: 添加包围符号**</span><br><span class="line">hello =&gt; ysiw<span class="string">' =&gt; '</span>hello<span class="string">'</span><br><span class="line">**yss: 整行添加包围符号**</span><br><span class="line">**yS/ySS 单独一行并有缩进**</span></span><br></pre></td></tr></table></figure></p>
<h2 id="nerdcommenter">nerdcommenter</h2><p><a href="https://github.com/scrooloose/nerdcommenter" target="_blank" rel="external">https://github.com/scrooloose/nerdcommenter</a></p>
<p>一个有用的注释插件。<br><code>&lt;Leader&gt;cc</code> 注释一行<br><code>&lt;Leader&gt;cu</code> 取消注释一行<br><code>&lt;Leader&gt;ca</code> 切换注释模式 ／／ 或 /**／<br><code>&lt;Leader&gt;cm</code> 以block的最简方式注释一段代码<br><code>&lt;Leader&gt;ci</code> 以独立注释单行的方式 注释选中的每一行， 注释模式取决<code>&lt;Leader&gt;ca</code><br><code>&lt;Leader&gt;cs</code> 以block的常规方式注释一段代码<br><code>&lt;Leader&gt;cA</code> 在行尾巴追加注释，注释模式取决于<code>&lt;Leader&gt;ca</code></p>
<h2 id="关于补全">关于补全</h2><p>spf13 提供了4种补全插件供我们选择(只能选择其中之一)</p>
<p>neocomplcache <a href="https://github.com/shougo/neocomplcache" target="_blank" rel="external">https://github.com/shougo/neocomplcache</a><br>YouCompleteMe <a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="external">https://github.com/Valloric/YouCompleteMe</a><br>neocomplete  <a href="https://github.com/Shougo/neocomplete.vim" target="_blank" rel="external">https://github.com/Shougo/neocomplete.vim</a></p>
<p>关于这几个补全插件的优劣，在各大论坛争论已久，neocomplete的作者在github上给出了一些自己看法，我觉得很值得参考<br><a href="https://github.com/skwp/dotfiles/issues/330#issuecomment-19034756" target="_blank" rel="external"> https://github.com/skwp/dotfiles/issues/330#issuecomment-19034756 </a></p>
<p>我目前在用neocomplcache， 稍稍有些转到neocomplete的倾向了～ :)</p>
<h2 id="PIV">PIV</h2><p><a href="https://github.com/spf13/PIV" target="_blank" rel="external">https://github.com/spf13/PIV</a></p>
<p>我大PHP的开发插件，可以方便的对function/class/variable 生成注释<code>&lt;Leader&gt;pd</code>, 在任意php内建函数上操作<code>&lt;Shift-k&gt;</code>，可以查看该函数的manual</p>
<h2 id="tabular">tabular</h2><p><a href="https://github.com/godlygeek/tabular" target="_blank" rel="external">https://github.com/godlygeek/tabular</a></p>
<p>对齐控们的福音,可以对 = : , 做对齐操作</p>
<p><code>&lt;Leader&gt;a=</code>  对<code>=</code>进行对齐操作<br><code>&lt;Leader&gt;a:</code>  对<code>:</code>进行对齐操作<br><code>&lt;Leader&gt;a::</code> 对<code>:</code> 后面的内容做对其操作，而<code>:</code>靠前紧贴<br><code>&lt;Leader&gt;a,</code>  对<code>,</code>进行对齐操作</p>
<h2 id="tagbar">tagbar</h2><p><a href="https://github.com/majutsushi/tagbar" target="_blank" rel="external">https://github.com/majutsushi/tagbar</a></p>
<p>Vim的tag插件，能在一个窗口中显示当前文件的tag，需要安装ctag/exuberant-ctags。<br>PS: 这个插件只展示tag，并不会做func的自动跳转</p>
<p>我的常用配置<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nnoremap &lt;<span class="constant">F6&gt;</span> <span class="symbol">:TagbarToggle&lt;CR&gt;</span> <span class="string">"我一般把tagbar绑在&lt;F6&gt;上</span><br><span class="line">let g:tagbar_autoclose=1 "</span>在一个tag上按回车后，自动跳转到tag在文件的位置，并关闭tagbar</span><br></pre></td></tr></table></figure></p>
<h1 id="写在最后">写在最后</h1><p>说是”简单几步”，最后还是唠唠叨叨的这么多，主要是希望大家用的更舒服些，对VIM的恐惧更少一些，上面的插件主要参考了spf13中的一些介绍，加上了自己的一些理解，应该够大家用上一段时间了。其实Github上的vim插件很多，通过Vundle可以很方便的安装以及管理，有兴趣的同学可以找一些适合自己的，慢慢的你就会觉得VIM无所不能了～ :)</p>
<p>今天就到这里， Enjoy~</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.harrycode.com/2014/05/05/simple-steps-to-build-cool-vim-development-environment/" data-id="cibq3ipoa000bgh6ao7l1jumb" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vim/">vim</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-初识GitBook" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/04/29/初识GitBook/" class="article-date">
  <time datetime="2014-04-29T07:27:00.000Z" itemprop="datePublished">2014-04-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/git/">git</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/29/初识GitBook/">初识GitBook</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>开源社区永远是惊喜不断的，这不，这几天一款叫做GitBook( <a href="https://github.com/GitbookIO/gitbook" target="_blank" rel="external">https://github.com/GitbookIO/gitbook</a> )的产品频繁的占据视线。如果你是一个电子书爱好者，如果你有一些开源项目并希望制作优雅华美的文档，或者你只是纯粹的想把github上的一些开源图书”据为己有”， GitBook都可以帮到你。</p>
<p>确切的来说，GitBook是一款用Node.js库构建的命令行工具，使用这个工具可以基于GitHub/Git／Markdown等电子书源码来制作精美的电子图书，今天我们以笔者最近在读的《Go Web 编程》(<a href="https://github.com/astaxie/build-web-application-with-golang" target="_blank" rel="external">https://github.com/astaxie/build-web-application-with-golang</a>) 尝试构建一本本地的电子图书。</p>
<h2 id="安装Nodejs">安装Nodejs</h2><p>安装GitBook首先需要有npm+nodejs，笔者的当前环境是Ubuntu 12.04 LTS, nodejs的版本较旧，我们需要先升级下下～</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo<span class="instruction"> add-apt-repository </span>ppa:chris-lea/node.js</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install python-software-properties python g++ make nodejs</span><br></pre></td></tr></table></figure>
<h2 id="安装GitBook">安装GitBook</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm <span class="keyword">install</span> gitbook -g</span><br></pre></td></tr></table></figure>
<h2 id="下载《Go_Web_编程》源码">下载《Go Web 编程》源码</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="string">git:</span><span class="comment">//github.com/astaxie/build-web-application-with-golang.git GoWeb</span></span><br></pre></td></tr></table></figure>
<h2 id="以Serve的方式浏览">以Serve的方式浏览</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> GoWeb/ebook <span class="comment">#进入ebook目录</span></span><br><span class="line">gitbook serve <span class="comment">#启动serve</span></span><br></pre></td></tr></table></figure>
<p>这样gitbook就以serve的方式启动了，此时我们可以访问 <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> ，就可以看到排版良好的电子书内容了</p>
<p><img class="center" src="http://user-image.logdown.io/user/1417/blog/1391/post/196328/sEyRsqDoTMaDSJEiLmDF_2014-04-29%2016:40:19%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="GoWeb-Book.png"></p>
<h2 id="GitBook的其他输出方式">GitBook的其他输出方式</h2><p>除了本地的Serve方式，GitBook还支持PDF,E-Book等方式的输出，不过需要安装一些转换插件,见官方文档：<a href="https://github.com/GitbookIO/gitbook#output-formats" target="_blank" rel="external">https://github.com/GitbookIO/gitbook#output-formats</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.harrycode.com/2014/04/29/初识GitBook/" data-id="cibq3ipnp0001gh6afrlh45dl" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tool/">Tool</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tools/">Tools</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux/" style="font-size: 20px;">Linux</a><a href="/tags/Tool/" style="font-size: 10px;">Tool</a><a href="/tags/Tools/" style="font-size: 15px;">Tools</a><a href="/tags/git/" style="font-size: 10px;">git</a><a href="/tags/php/" style="font-size: 10px;">php</a><a href="/tags/vim/" style="font-size: 10px;">vim</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">十二月 2014</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">六月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">五月 2014</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">四月 2014</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/07/05/nginx-manual-note-CORE-FUNC/">Nginx手册阅读笔记 —— 核心指令</a>
          </li>
        
          <li>
            <a href="/2014/12/03/2014-12-03-to-hadoop-working-mechanism/">[转]  Hadoop工作机制</a>
          </li>
        
          <li>
            <a href="/2014/12/03/to-understand-mapreduce-data-flow/">[转] 理解MapReduce数据流</a>
          </li>
        
          <li>
            <a href="/2014/12/03/to-briefly-introduce-each-major-module-of-hadoop/">[转] 简要介绍Hadoop的各个主要模块</a>
          </li>
        
          <li>
            <a href="/2014/12/03/to-to-quickly-grasp-mapreduce/">[转] 快速理解MapReduce</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Harry<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->


<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
                processEscapes: true
                    
}
  
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
                  
}
    
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Queue(function() {
            var all = MathJax.Hub.getAllJax(), i;
            for(i=0; i < all.length; i += 1) {
                            all[i].SourceElement().parentNode.className += ' has-jax';
                                    
            }
                
        });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<script src="/js/script.js" type="text/javascript"></script>

</div>
</body>
</html>
